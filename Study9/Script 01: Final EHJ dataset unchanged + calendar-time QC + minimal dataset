# ==============================================================================
# PROFID — UmBIZO Study 9
# Script 01: Final EHJ dataset unchanged + calendar-time QC 
# Autor: Amina BOUDAMAANA
# Objective
# - We use existing calendar-time anchor (Time_zero_Y)
# - Produce transparent denominators and crude temporal summaries (2000–2020):
# * Non-ICD: SCD counts + crude rates (per 1,000 person-years)
# * ICD: ICD proxy outcome defined as Status==1 among ICD patients
# -> ICD_proxy_bin = 1 if ICD_bin==1 & Status==1; else 0
#
# 
# - Provide calendar-band summaries for stable visualisation:
# bands: 2000–2004, 2005–2009, 2010–2014, 2015–2020
# - Provide QC file highlighting sparse years (e.g., 2005 artefact)
#
# Input:
# - df_handled.csv (expected n≈139,915; p≈107)
# ==============================================================================
suppressPackageStartupMessages({
  library(dplyr)
  library(readr)
  library(stringr)
  library(tibble)
})

rm(list = ls()); gc()
# ==============================================================================
# 0) Paths (EDIT THESE TWO ONLY)
# ==============================================================================
IN_ROOT <- "S:/AG/f-dhzC-profid/Data Transfer to Charite"
OUT_ROOT <- "T:/Study_9"
dir.create(OUT_ROOT, recursive = TRUE, showWarnings = FALSE)

IN_CSV <- file.path(IN_ROOT, "df_handled.csv")
OUT_DIR <- file.path(OUT_ROOT, "Results_Study9", "Script01_CalendarTime_QC")
dir.create(OUT_DIR, recursive = TRUE, showWarnings = FALSE)

log_line <- function(...) {
  cat(
    paste0(
      format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
      " | ",
      paste0(..., collapse = ""),
      "\n"
    )
  )
}
# ==============================================================================
# 1) Load dataset
# ==============================================================================
stopifnot(file.exists(IN_CSV))

df0 <- readr::read_csv(IN_CSV, show_col_types = FALSE, progress = FALSE)
stopifnot(is.data.frame(df0))

log_line("[OK] Loaded input (CSV): ", IN_CSV)
log_line("[OK] Dimensions: ", nrow(df0), " x ", ncol(df0))
   #  Dimensions: 139915 x 107
nm <- names(df0)
readr::write_csv(tibble(colname = nm), file.path(OUT_DIR, "columns_snapshot.csv"))
# ==============================================================================
# 2) Required columns (edit only if names differ)
# ==============================================================================
col_icd <- "ICD_status"
col_scd <- "SCD_event"
col_y <- "Time_zero_Y"
col_status <- "Status" 

# Optional
col_ym <- "Time_zero_Ym"
col_base <- "Baseline_type"
col_db <- if ("DB" %in% nm) "DB" else NA_character_
col_dbp <- if ("DBP" %in% nm) "DBP" else NA_character_

req <- c(col_icd, col_scd, col_y, col_status)
miss <- req[!req %in% nm]
if (length(miss) > 0) stop("Missing required columns: ", paste(miss, collapse = ", "))
# ==============================================================================
# 3) Helpers
# ==============================================================================
to_bin01 <- function(x) {
  if (is.logical(x)) return(as.integer(x))
  if (is.numeric(x)) return(as.integer(x > 0))
  xx <- tolower(trimws(as.character(x)))
  as.integer(xx %in% c("1","y","yes","true","t","present","event","icd"))
}
as_num_safely <- function(x) suppressWarnings(as.numeric(as.character(x)))

make_band_2000_2020 <- function(y) {
  cut(
    y,
    breaks = c(1999, 2004, 2009, 2014, 2020),
    labels = c("2000–2004", "2005–2009", "2010–2014", "2015–2020"),
    right = TRUE
  )
}
# ==============================================================================
# 4) Person-time (prefer py; else follow-up months)
# ==============================================================================
col_py <- if ("py" %in% nm) "py" else NA_character_
col_fmo <- if ("ftime_mo_int" %in% nm) "ftime_mo_int" else NA_character_

log_line("[INFO] Person-time column (py): ", ifelse(is.na(col_py), "<not found>", col_py))
log_line("[INFO] Follow-up months (ftime_mo_int): ", ifelse(is.na(col_fmo), "<not found>", col_fmo))
# ==============================================================================
# 5) Build derived dataset (NO new inclusion filters; add calendar-time + proxy vars)
# ==============================================================================
df1 <- df0 %>%
  mutate(
    Year_index = suppressWarnings(as.integer(.data[[col_y]])),
    YearMonth_index = if (col_ym %in% nm) as.character(.data[[col_ym]]) else NA_character_,
    
    ICD_bin = to_bin01(.data[[col_icd]]),
    SCD_bin = to_bin01(.data[[col_scd]]),
    
    # Status as provided in extract
    Status_num = suppressWarnings(as.integer(.data[[col_status]])),
    
    # Person-years
    person_years = if (!is.na(col_py)) {
      as_num_safely(.data[[col_py]])
    } else if (!is.na(col_fmo)) {
      as_num_safely(.data[[col_fmo]]) / 12
    } else {
      NA_real_
    },
    
    # ICD proxy outcome: Status==1 among ICD patients (else 0)
    ICD_proxy_bin = ifelse(ICD_bin == 1L & Status_num == 1L, 1L, 0L)
  )

# Main calendar window for summaries
START_Y <- 2000L
END_Y <- 2020L

dat <- df1 %>%
  filter(!is.na(Year_index), Year_index >= START_Y, Year_index <= END_Y) %>%
  mutate(
    cohort = ifelse(ICD_bin == 1L, "ICD", "Non-ICD"),
    band_2000_2020 = make_band_2000_2020(Year_index)
  )

log_line("[OK] Restricted to 2000–2020: n=", nrow(dat))
   #Restricted to 2000–2020: n=136336
# ==============================================================================
# 6) QC tables
# ==============================================================================
year_audit <- tibble(
  n = nrow(dat),
  year_missing = sum(is.na(dat$Year_index)),
  year_min = suppressWarnings(min(dat$Year_index, na.rm = TRUE)),
  year_max = suppressWarnings(max(dat$Year_index, na.rm = TRUE))
)
write.csv(year_audit, file.path(OUT_DIR, "year_audit.csv"))

py_audit <- tibble(
  py_source = ifelse(is.na(col_py) & is.na(col_fmo), "<none>", ifelse(!is.na(col_py), col_py, col_fmo)),
  py_missing = sum(is.na(dat$person_years)),
  py_nonpositive = sum(!is.na(dat$person_years) & dat$person_years <= 0),
  py_min = suppressWarnings(min(dat$person_years, na.rm = TRUE)),
  py_max = suppressWarnings(max(dat$person_years, na.rm = TRUE))
)
write.csv(py_audit, file.path(OUT_DIR, "person_years_audit.csv"))

if (col_base %in% nm) {
  base_dist <- dat %>%
    count(.data[[col_base]], name = "n") %>%
    arrange(desc(n))
  write.csv(base_dist, file.path(OUT_DIR, "baseline_type_distribution.csv"))
}
# ==============================================================================
# 7) Coverage by year (overall + by ICD status)
# ==============================================================================
coverage_by_year_overall <- dat %>%
  group_by(Year_index) %>%
  summarise(
    n = n(),
    scd_events_total = sum(SCD_bin == 1L, na.rm = TRUE),
    icd_share = mean(ICD_bin == 1L, na.rm = TRUE),
    person_years = if (!all(is.na(person_years))) sum(person_years, na.rm = TRUE) else NA_real_,
    .groups = "drop"
  ) %>%
  arrange(Year_index)
write.csv(coverage_by_year_overall, file.path(OUT_DIR, "coverage_by_year_overall.csv"))

coverage_by_year_by_icd <- dat %>%
  group_by(Year_index, cohort) %>%
  summarise(
    n = n(),
    scd_events = sum(SCD_bin == 1L, na.rm = TRUE),
    icd_proxy_events = sum(ICD_proxy_bin == 1L, na.rm = TRUE),
    person_years = if (!all(is.na(person_years))) sum(person_years, na.rm = TRUE) else NA_real_,
    .groups = "drop"
  ) %>%
  arrange(Year_index, cohort)
write.csv(coverage_by_year_by_icd, file.path(OUT_DIR, "coverage_by_year_by_icd.csv"))

availability_by_year <- dat %>%
  group_by(Year_index) %>%
  summarise(
    n_total = n(),
    n_nonICD = sum(cohort == "Non-ICD"),
    n_ICD = sum(cohort == "ICD"),
    .groups = "drop"
  ) %>%
  arrange(Year_index)
write.csv(availability_by_year, file.path(OUT_DIR, "availability_by_year.csv"))
# ==============================================================================
# 8) Main output: Non-ICD SCD counts + crude rates by year
# ==============================================================================
scd_nonICD_by_year <- dat %>%
  filter(cohort == "Non-ICD") %>%
  group_by(Year_index) %>%
  summarise(
    n = n(),
    scd_events = sum(SCD_bin == 1L, na.rm = TRUE),
    person_years = if (!all(is.na(person_years))) sum(person_years, na.rm = TRUE) else NA_real_,
    scd_rate_per_1000py = ifelse(!is.na(person_years) & person_years > 0,
                                 1000 * scd_events / person_years,
                                 NA_real_),
    .groups = "drop"
  ) %>%
  arrange(Year_index)
write.csv(scd_nonICD_by_year, file.path(OUT_DIR, "scd_nonICD_by_year_counts_rates.csv"))
# ==============================================================================
# 9) ICD proxy outcome by year (Status==1 in ICD patients)
# ==============================================================================
icd_proxy_by_year <- dat %>%
  filter(cohort == "ICD") %>%
  group_by(Year_index) %>%
  summarise(
    n = n(),
    icd_proxy_events = sum(ICD_proxy_bin == 1L, na.rm = TRUE),
    person_years = if (!all(is.na(person_years))) sum(person_years, na.rm = TRUE) else NA_real_,
    icd_proxy_rate_per_1000py = ifelse(!is.na(person_years) & person_years > 0,
                                       1000 * icd_proxy_events / person_years,
                                       NA_real_),
    .groups = "drop"
  ) %>%
  arrange(Year_index)
write.csv(icd_proxy_by_year, file.path(OUT_DIR, "icd_proxy_by_year_counts_rates.csv"))

# Status distribution in ICD cohort (QC)
status_icd_tab <- dat %>%
  filter(cohort == "ICD") %>%
  count(Status_num, name = "n") %>%
  arrange(desc(n))
write.csv(status_icd_tab, file.path(OUT_DIR, "Status_distribution_in_ICD_cohort_2000_2020.csv"))

# ==============================================================================
# 10) Calendar bands 
# ==============================================================================
coverage_by_band_by_icd <- dat %>%
  filter(!is.na(band_2000_2020)) %>%
  group_by(band_2000_2020, cohort) %>%
  summarise(
    n = n(),
    scd_events = sum(SCD_bin == 1L, na.rm = TRUE),
    icd_proxy_events = sum(ICD_proxy_bin == 1L, na.rm = TRUE),
    person_years = if (!all(is.na(person_years))) sum(person_years, na.rm = TRUE) else NA_real_,
    .groups = "drop"
  ) %>%
  arrange(band_2000_2020, cohort)
write.csv(coverage_by_band_by_icd, file.path(OUT_DIR, "coverage_by_band_by_icd_2000_2020.csv"))

scd_nonICD_by_band <- dat %>%
  filter(cohort == "Non-ICD", !is.na(band_2000_2020)) %>%
  group_by(band_2000_2020) %>%
  summarise(
    n = n(),
    scd_events = sum(SCD_bin == 1L, na.rm = TRUE),
    person_years = if (!all(is.na(person_years))) sum(person_years, na.rm = TRUE) else NA_real_,
    scd_rate_per_1000py = ifelse(!is.na(person_years) & person_years > 0,
                                 1000 * scd_events / person_years,
                                 NA_real_),
    .groups = "drop"
  ) %>%
  arrange(band_2000_2020)
write.csv(scd_nonICD_by_band, file.path(OUT_DIR, "scd_nonICD_by_band_counts_rates_2000_2020.csv"))

icd_proxy_by_band <- dat %>%
  filter(cohort == "ICD", !is.na(band_2000_2020)) %>%
  group_by(band_2000_2020) %>%
  summarise(
    n = n(),
    icd_proxy_events = sum(ICD_proxy_bin == 1L, na.rm = TRUE),
    person_years = if (!all(is.na(person_years))) sum(person_years, na.rm = TRUE) else NA_real_,
    icd_proxy_rate_per_1000py = ifelse(!is.na(person_years) & person_years > 0,
                                       1000 * icd_proxy_events / person_years,
                                       NA_real_),
    .groups = "drop"
  ) %>%
  arrange(band_2000_2020)
write.csv(icd_proxy_by_band, file.path(OUT_DIR, "icd_proxy_by_band_counts_rates_2000_2020.csv"))
# ==============================================================================
# 11) QC: highlight sparse years (explains artefacts like 2005)
# ==============================================================================
# we define "sparse" as very small denominators or person-time (tunable thresholds)
SPARSE_N <- 50L
SPARSE_PY <- 50

sparse_years_nonICD <- scd_nonICD_by_year %>%
  mutate(
    is_sparse_n = n < SPARSE_N,
    is_sparse_py = !is.na(person_years) & person_years < SPARSE_PY,
    flag_sparse = is_sparse_n | is_sparse_py
  ) %>%
  filter(flag_sparse) %>%
  arrange(Year_index)

write.csv(sparse_years_nonICD, file.path(OUT_DIR, "QC_sparse_years_nonICD.csv"))

# Log the 2005 row explicitly if present
row2005 <- scd_nonICD_by_year %>% filter(Year_index == 2005)
if (nrow(row2005) == 1) {
  log_line(
    "[QC] 2005 (Non-ICD): n=", row2005$n,
    " | SCD=", row2005$scd_events,
    " | PY=", format(row2005$person_years, digits = 6),
    " | rate/1000PY=", format(row2005$scd_rate_per_1000py, digits = 6)
  )
}
    # [QC] 2005 (Non-ICD): n=3 | SCD=1 | PY=5.48793 | rate/1000PY=182.218

# ==============================================================================
# 12) ICD cohort audit: FAT / VT / VF fields by name + NSVT distribution
# ==============================================================================
pat_vtvf <- "(^|_)(fat|vt|vf)(_|$)|ventric|ventri|tachy|fibrill"
cand_vtvf <- names(df0)[stringr::str_detect(tolower(names(df0)), pat_vtvf)]

audit_vtvf <- tibble(
  pattern = pat_vtvf,
  n_candidates = length(cand_vtvf),
  candidates = ifelse(length(cand_vtvf) == 0, "<none>", paste(cand_vtvf, collapse = ", "))
)
write.csv(audit_vtvf, file.path(OUT_DIR, "audit_FAT_VT_VF_candidates.csv"))

pat_rhythm <- "(nsvt|af|atrial|flutter|anti[_ ]?arrhyth|arrhyth|tachy)"
cand_rhythm <- names(df0)[stringr::str_detect(tolower(names(df0)), pat_rhythm)]
rhythm_list <- tibble(
  pattern = pat_rhythm,
  n_fields = length(cand_rhythm),
  fields = ifelse(length(cand_rhythm) == 0, "<none>", paste(cand_rhythm, collapse = ", "))
)
write_=.csv(rhythm_list, file.path(OUT_DIR, "audit_rhythm_fields_broadscan.csv"))

if ("NSVT" %in% names(df0)) {
  tb_nsvt <- table(df0$NSVT[df0[[col_icd]] == 1], useNA = "ifany")
  nsvt_tab <- tibble(value = names(tb_nsvt), n = as.integer(tb_nsvt))
  write_csv(nsvt_tab, file.path(OUT_DIR, "NSVT_distribution_in_ICD_cohort.csv"))
}
# ==============================================================================
# 13) Save minimal dataset for Script 02 (must include Status + ICD_proxy_bin)
# ==============================================================================
keep_vars <- unique(c(
  col_y, col_icd, col_scd, col_status,
  if (col_ym %in% nm) col_ym else NULL,
  if (col_base %in% nm) col_base else NULL,
  if (!is.na(col_db)) col_db else NULL,
  if (!is.na(col_dbp)) col_dbp else NULL,
  if (!is.na(col_py)) col_py else NULL,
  if (!is.na(col_fmo)) col_fmo else NULL,
  "Year_index", "YearMonth_index", "ICD_bin", "SCD_bin", "person_years",
  "Status_num", "ICD_proxy_bin",
  "band_2000_2020"
))

dat_min <- dat %>% select(any_of(keep_vars))
saveRDS(dat_min, file.path(OUT_DIR, "df_study9_minimal.rds"))

log_line("[DONE] Outputs written to: ", OUT_DIR)
log_line("[DONE] Minimal dataset saved: ", file.path(OUT_DIR, "df_study9_minimal.rds"))
# ==============================================================================
# 14) Quick file existence check (optional)
# ==============================================================================
files <- c(
  "columns_snapshot.csv",
  "year_audit.csv",
  "person_years_audit.csv",
  "baseline_type_distribution.csv",
  "coverage_by_year_overall.csv",
  "coverage_by_year_by_icd.csv",
  "availability_by_year.csv",
  "scd_nonICD_by_year_counts_rates.csv",
  "icd_proxy_by_year_counts_rates.csv",
  "coverage_by_band_by_icd_2000_2020.csv",
  "scd_nonICD_by_band_counts_rates_2000_2020.csv",
  "icd_proxy_by_band_counts_rates_2000_2020.csv",
  "QC_sparse_years_nonICD.csv",
  "Status_distribution_in_ICD_cohort_2000_2020.csv",
  "df_study9_minimal.rds"
)
print(file.info(file.path(OUT_DIR, files))[, c("size","mtime")])
