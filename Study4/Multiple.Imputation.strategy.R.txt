##################################################################################################################
# projet: UmBIZO- PROFID_Study4 (SCD post-MI, age- stratified)
# Script: 10_Multiple_Imputation_strategy.R
# Author: Amina Boudamaana
#  ===================================================================================================================
## ================= MI EXPORT  & chatty (uses df_handled_cc) =================
suppressPackageStartupMessages({
  library(mice); library(survival)
  suppressWarnings(try(library(cmprsk), silent = TRUE))
})

## ---- OUTPUT helpers ---------------------------------------------------------------
OUT_RT <- file.path(getwd(), "Results_tables")
OUT_MI <- file.path(getwd(), "Results_MI")
dir.create(OUT_RT, recursive = TRUE, showWarnings = FALSE)
dir.create(OUT_MI, recursive = TRUE, showWarnings = FALSE)

msg <- function(fmt, ...) cat(sprintf(fmt, ...), "\n")
wcsv <- function(x, file) { dir.create(dirname(file), TRUE, FALSE); utils::write.csv(x, file, row.names = FALSE) }
wreadme <- function(txt, file) { dir.create(dirname(file), TRUE, FALSE); writeLines(txt, file) }

## ---- DATA (use df_handled_cc) ----------------------------------------------------
stopifnot(exists("df_handled"), is.data.frame(df_handled))
df <- as.data.frame(df_handled)

## Normalize column names we depend on
if (!"Survival_time" %in% names(df) && "survival_time" %in% names(df)) {
  names(df)[names(df) == "survival_time"] <- "Survival_time"
}

## Time variables
if (!"time_years" %in% names(df)) {
  if ("ftime_mo_int" %in% names(df)) df$time_years <- as.numeric(df$ftime_mo_int)/12
  else if ("Survival_time" %in% names(df)) df$time_years <- as.numeric(df$Survival_time)/12
  else stop("No time variable found (need time_years or ftime_mo_int or Survival_time).")
} else df$time_years <- as.numeric(df$time_years)

if (!"ftime_mo_int" %in% names(df)) {
  if ("Survival_time" %in% names(df)) df$ftime_mo_int <- as.integer(round(as.numeric(df$Survival_time)))
  else df$ftime_mo_int <- as.integer(round(df$time_years*12))
}

## Status coding
status_col <- if ("fstatus" %in% names(df)) "fstatus" else if ("Status" %in% names(df)) "Status" else NA_character_
stopifnot(!is.na(status_col))
df[[status_col]] <- suppressWarnings(as.integer(df[[status_col]]))

## event_scd for Cox (1=SCD, 0 otherwise)
if (!"event_scd" %in% names(df)) {
  df$event_scd <- as.integer(df[[status_col]] == 1L)
} else df$event_scd <- as.integer(df$event_scd)

## fstatus for Fine-Gray (0=cens,1=SCD,2=non-SCD)
if (!"fstatus" %in% names(df)) {
  S <- suppressWarnings(as.integer(df$Status))
  df$fstatus <- ifelse(S==1L,1L, ifelse(S==2L,2L, ifelse(S==0L,0L, NA_integer_)))
}

## Age group levels
if ("age_group" %in% names(df)) {
  df$age_group <- factor(as.character(df$age_group),
                         levels = c("<=50","51-65","66-75",">75"), ordered = TRUE)
}

## Covariates 
cand_cont <- c("LVEF","eGFR","BMI","Haemoglobin")
cand_bin <- c("Diabetes","Hypertension","ACE_inhibitor","ARB","Anti_coagulant",
              "Beta_blocker","Statin") # keep if present
cand_fac <- c("MR_severity")
covars <- intersect(c(cand_cont, cand_bin, cand_fac), names(df))
rhs_vars <- c("age_group", covars)

aux_vars <- intersect(c("cohort_id","center_id","index_year","flag_within40d"), names(df))
## ---- 0) Build an imputation frame -------------------------------------------------
## --- A) 
keep_cols <- unique(c("time_years","ftime_mo_int","Status","fstatus","event_scd","age_group",
                      covars, aux_vars))
dat_imp <- df[, intersect(keep_cols, names(df)), drop = FALSE]

## 
to_yesno <- function(z){
  if (is.factor(z)) z <- as.character(z)
  if (is.logical(z) || is.numeric(z))
    return(factor(ifelse(as.numeric(z)==1,"Yes","No"), levels=c("No","Yes")))
  z <- trimws(tolower(as.character(z)))
  factor(ifelse(z %in% c("1","y","yes","true"),"Yes",
                ifelse(z %in% c("0","n","no","false"),"No", NA)),
         levels=c("No","Yes"))
}
for (v in intersect(cand_bin, names(dat_imp))) dat_imp[[v]] <- to_yesno(dat_imp[[v]])
if ("MR_severity" %in% names(dat_imp)) dat_imp$MR_severity <- factor(dat_imp$MR_severity, ordered = TRUE)
if ("age_group" %in% names(dat_imp)) dat_imp$age_group <- droplevels(dat_imp$age_group)

#
# matrices
meth <- make.method(dat_imp)
pred <- make.predictorMatrix(dat_imp)

# 1) 
no_imp <- c("time_years","ftime_mo_int","Status","fstatus","event_scd","age_group")
no_imp <- intersect(no_imp, colnames(dat_imp))

#
  not_imp <- intersect(c("time_years","ftime_mo_int","Status","fstatus","event_scd"), names(dat_imp))
meth[not_imp] <- ""
pred[not_imp, ] <- 0

# age_group 
if ("age_group" %in% names(dat_imp)) {
  meth["age_group"] <- ""
  pred["age_group", ] <- 0 
  pred[, "age_group"] <- 1
  dat_imp$age_group <- droplevels(dat_imp$age_group)
}

#
# 2)imputation
cont <- intersect(c("LVEF","eGFR","BMI","Haemoglobin"), colnames(dat_imp))
bin <- intersect(c("Diabetes","Hypertension","ACE_inhibitor","ARB","Anti_coagulant"), colnames(dat_imp))
ord <- intersect(c("MR_severity"), colnames(dat_imp))

meth[cont] <- "pmm" # continues
meth[bin] <- "logreg" # binaires 0/1
ord <- intersect(c("MR_severity"), names(dat_imp))
meth[ord] <- "polr" 

# 3)  post-traitement
post <- make.post(dat_imp)
ub <- c(LVEF=100, eGFR=200, BMI=80, Haemoglobin=25,
        "NTproBNP"=1e6, "NTPOBNP"=1e6, "Troponin_T"=1e4, "TroponinI"=1e4)
for (v in intersect(names(ub), colnames(dat_imp))) {
  post[v] <- sprintf("imp[[j]][, i] <- pmin(imp[[j]][, i], %g)", ub[v])
}

# ==========================================================================================
## --- F) MICE with post
# ==========================================================================================
set.seed(2025)
imp <- mice(dat_imp, m = 2, maxit = 20,
            method = meth, predictorMatrix = pred,
            post = post,
            print = FALSE)

msg("[info] MICE completed: %d imputed datasets", imp$m)
# m=20
M <- 20
set.seed(2025)
imp <- mice(
  dat_imp,
  m = M, # <--- 20 imputations
  maxit = 20,
  method = meth,
  predictorMatrix = pred,
  post = post,
  print = FALSE
)
stopifnot(imp$m == M)
msg("[info] MICE completed: %d imputed datasets", imp$m)
# ======================================================
# Check
names(imp$data) # "event_scd"= exist
table(imp$data$event_scd, useNA="ifany") # 0/1
## 1) L’issue et le temps ne sont pas imputés (méthode vide)
stopifnot(imp$method["event_scd"] == "")
stopifnot(imp$method["Status"] == "")
stopifnot(imp$method["fstatus"] == "")
stopifnot(imp$method["time_years"] == "")
stopifnot(imp$method["ftime_mo_int"] == "")

## 
pred <- imp$predictorMatrix
stopifnot(colSums(pred[, c("event_scd","Status","fstatus","time_years","ftime_mo_int")]) > 0)

## 3) 
imp$method[c("LVEF","eGFR","BMI","Haemoglobin")] # "pmm"
imp$method[c("Diabetes","Hypertension","ACE_inhibitor",
             "ARB","Anti_coagulant")] # "logreg" 
imp$method["age_group"] # "polyreg" or ""

## 4) 
# ex. ftime_mo_int =y round(time_years*12)
# ex. CRP_log1p ~ I(log1p(CRP))

## 5) Convergence & distributions
plot(imp, c("eGFR","BMI","Haemoglobin","LVEF")) # traceplots 
mice::densityplot(imp, ~ eGFR + BMI + Haemoglobin) 
mice::stripplot(imp, eGFR + BMI + Haemoglobin) # imputed vs observed semblables

## 6)after imputation
cmpl <- complete(imp, 1)
sapply(c("LVEF","eGFR","BMI","Haemoglobin",
         "Diabetes","Hypertension","ACE_inhibitor","ARB","Anti_coagulant"),
       function(v) sum(is.na(cmpl[[v]])))
##
cmp1 <- complete(imp, 1)
sapply(c("LVEF","eGFR","BMI","Haemoglobin",
         "Diabetes","Hypertension","ACE_inhibitor","ARB","Anti_coagulant"),
       function(v) sum(is.na(cmp1[[v]]))) # bien [[ ]]
dat <- imp$data
pred <- imp$predictorMatrix
meth <- make.method(dat)


meth[c("time_years","ftime_mo_int","Status","fstatus","event_scd")] <- ""

# numerics
meth[c("LVEF","eGFR","BMI","Haemoglobin")] <- "pmm"

# binaires 
bin <- c("Diabetes","Hypertension","ACE_inhibitor","ARB","Anti_coagulant")
dat[bin] <- lapply(dat[bin], function(x) factor(x, levels = c("No","Yes")))
meth[bin] <- "logreg"


suppressPackageStartupMessages(library(mice))

## 0) Choose a robust output folder 
OUT_MI <- if (dir.exists("T:/study_4")) file.path("T:/study_4", "Imputed_data") else
  file.path(getwd(), "Imputed_data")
dir.create(OUT_MI, recursive = TRUE, showWarnings = FALSE)
message("[Export dir] ", normalizePath(OUT_MI, winslash = "/", mustWork = FALSE))

## 1) 'imp' must be our mids object returned by mice()
stopifnot(inherits(imp, "mids"))

## 2) Save the MICE object itself 
saveRDS(imp, file.path(OUT_MI, "mice_imp_object.rds"))

## 3) Export each imputed dataset separately (CSV + RDS)
for(k in seq_len(imp$m)){
  dk <- mice::complete(imp, action = k) # data.frame for imputation k
  write.csv(dk, file.path(OUT_MI, sprintf("df_imputed_%02d.csv", k)), row.names = FALSE)
  saveRDS(dk, file.path(OUT_MI, sprintf("df_imputed_%02d.rds", k)))
}
message(sprintf("[OK] Wrote %d CSVs and %d RDS files.", imp$m, imp$m))

## 4) Also export a single long file stacking all imputations
## .imp = 0 is the original incomplete data, 1..m are the imputed sets
imp_long <- mice::complete(imp, action = "long", include = TRUE)
write.csv(imp_long, file.path(OUT_MI, "df_imputed_LONG.csv"), row.names = FALSE)
saveRDS(imp_long, file.path(OUT_MI, "df_imputed_LONG.rds"))
message("[OK] Wrote stacked long file (CSV + RDS).")

## 5) (Optional) Zip the 20 CSVs for easy download
csvs <- list.files(OUT_MI, pattern = "^df_imputed_\\d+\\.csv$", full.names = TRUE)
if (length(csvs)) {
  suppressWarnings(try({
    utils::zip(zipfile = file.path(OUT_MI, "imputed_csvs.zip"), files = csvs, flags = "-j")
    message("[OK] Created ZIP: imputed_csvs.zip")
  }, silent = TRUE))
}

## 6) Quick listing
print(list.files(OUT_MI, full.names = TRUE))

# ===================================================================================================================
## ---- 3) Cox across imputations + pooling -----------------------------------------
# ===================================================================================================================
cox_rhs <- paste(c("age_group", covars), collapse = " + ")
fit_mi <- with(
  imp,
  survival::coxph(
    as.formula(paste("Surv(time_years, event_scd) ~", cox_rhs)),
    ties = "efron"
  )
)
pool_cox <- mice::pool(fit_mi)
cox_sum <- summary(pool_cox, conf.int = TRUE, exponentiate = TRUE)
print(cox_sum)

wcsv(cox_sum, file.path(OUT_MI, "Cox_pooled_MI.csv"))
# ====================================================================================================================
## ---- 4)  Complete-case comparison_ COX MODEL --------------------------------------
# ====================================================================================================================
need <- unique(c("time_years","event_scd","ftime_mo_int","fstatus","age_group", covars))
cc_idx <- complete.cases(df[, intersect(need, names(df))])
if (any(cc_idx)) {
  df_cc <- df[cc_idx, intersect(need, names(df)), drop=FALSE]
  cox_cc <- survival::coxph(cox_form, data = df_cc, ties = "efron")
  cc_hr <- data.frame(term = names(coef(cox_cc)),
                      HR = exp(coef(cox_cc)),
                      LCL_95 = exp(confint(cox_cc)[,1]),
                      UCL_95 = exp(confint(cox_cc)[,2]), row.names=NULL)
  ## align columns & export comparison
  comb <- merge(cox_sum[, c("term","estimate","2.5 %","97.5 %")], cc_hr, by = "term", all = TRUE)
  names(comb)[2:4] <- c("HR_MI","LCL_MI","UCL_MI")
  wcsv(comb, file.path(OUT_MI, "Cox_MI_vs_CC.csv"))
}
# =======================================================================================================
## ---- 5)  Fine–Gray + Rubin scalar pooling ------------------------------
# =======================================================================================================
if (requireNamespace("cmprsk", quietly = TRUE)) {
  sets <- mice::complete(imp, action = "all")
  
  fit_one <- function(d){
    keep <- complete.cases(d[, intersect(c("ftime_mo_int","fstatus","age_group", covars), names(d))])
    if (!any(keep)) return(NULL)
    dd <- d[keep, , drop=FALSE]
    X <- model.matrix(as.formula(paste("~", paste(c("age_group", covars), collapse=" + "))), data=dd)[,-1,drop=FALSE]
    fit <- try(cmprsk::crr(ftime = dd$ftime_mo_int, fstatus = dd$fstatus, cov1 = X,
                           failcode = 1, cencode = 0, variance = TRUE), silent = TRUE)
    if (inherits(fit,"try-error")) return(NULL)
    list(beta = fit$coef, var = fit$var)
  }
  fits <- Filter(Negate(is.null), lapply(sets, fit_one))
  if (length(fits) >= 2) {
    all_par <- Reduce(union, lapply(fits, function(x) names(x$beta)))
    B <- do.call(cbind, lapply(fits, function(x){ b <- setNames(rep(NA_real_, length(all_par)), all_par); b[names(x$beta)] <- x$beta; b }))
    U <- lapply(fits, function(x){ V <- matrix(NA_real_, length(all_par), length(all_par), dimnames=list(all_par,all_par)); V[names(x$beta),names(x$beta)] <- x$var; V })
    pool_scalar <- function(j){
      Q <- B[j,]; Ujj <- vapply(U, function(V) V[j,j], numeric(1))
      ps <- mice::pool.scalar(Q=Q, U=Ujj, k=ncol(B))
      c(est = ps$qbar, se = sqrt(ps$t))
    }
    RES <- t(sapply(seq_along(all_par), pool_scalar))
    out_fg <- data.frame(term = all_par, logSHR = RES[,"est"], SE = RES[,"se"])
    out_fg$SHR <- exp(out_fg$logSHR)
    out_fg$LCL_95 <- exp(out_fg$logSHR - 1.96*out_fg$SE)
    out_fg$UCL_95 <- exp(out_fg$logSHR + 1.96*out_fg$SE)
    wcsv(out_fg, file.path(OUT_MI, "FineGray_pooled_MI.csv"))
  } else {
    wreadme("Fine-Gray not exported: fewer than 2 valid fits to pool.", file.path(OUT_MI,"README_FG.txt"))
  }
} else {
  wreadme("Package 'cmprsk' not available – only Cox MI results exported.", file.path(OUT_MI,"README_FG.txt"))
}

# ======================================================================================================================
## ---- 7) Final listing -------------------------------------------------------------
# ======================================================================================================================
msg("[MI outputs]"); print(list.files(OUT_MI, full.names = TRUE))
msg("[Results_tables]"); print(list.files(OUT_RT, full.names = TRUE))
