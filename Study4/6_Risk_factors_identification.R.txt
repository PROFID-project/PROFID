
##################################################################################################################
# projet: UmBIZO- PROFID_Study4 (SCD post-MI, age- stratified)
# Script: 07_Validation_FG_Model_and_Performance.R
# Author: Amina Boudamaana
# ====================================================================================================
# Study 4 — Validation model Fine-Gray and Performance
# ====================================================================================================
# ====================================================================================================
## ===== FG discrimination  =====
# ====================================================================================================
suppressPackageStartupMessages({
  library(cmprsk)
  library(survival)
  library(timeROC)
})

## 0) data( months)
stopifnot(exists("df_handled_cc"), is.data.frame(df_handled_cc))
canon <- c("<=50","51-65","66-75",">75")
clean_age <- function(x){
  x <- trimws(as.character(x))
  x <- gsub("\u2264","<=",x)
  x <- gsub("\u2013|\u2014|–|—","-",x) # tirets exotiques -> "-"
  x <- gsub("\\s+","",x)
  x[x %in% c("<=50","<=50y","<=50yrs","<=50years")] <- "<=50"
  x[x %in% c("51-65","51–65")] <- "51-65"
  x[x %in% c("66-75","66–75")] <- "66-75"
  x[grepl("^> ?75|^>=?76|\\b76\\+\\b", x)] <- ">75"
  factor(x, levels = canon)
}

df_cr <- within(df_handled_cc, {

  time_months <- as.integer(round(ftime_mo_int))
  Status <- as.integer(fstatus) # 0=cens, 1=SCD, 2=non-SCD
  age_group <- clean_age(age_group)
})

df_cr <- subset(df_cr,
                is.finite(time_months) & time_months > 0 &
                  Status %in% 0:2 & !is.na(age_group))

## 1) Fine-Gray model
X_age <- model.matrix(~ age_group, data = df_cr)[, -1, drop = FALSE] # ref <=50
fit_fg <- crr(ftime = df_cr$time_months,
              fstatus = df_cr$Status,
              cov1 = X_age,
              failcode = 1, cencode = 0, variance = TRUE)

## 2) Table SHR 
beta <- setNames(as.numeric(fit_fg$coef), colnames(X_age))
se <- sqrt(diag(fit_fg$var))
shr_tab <- data.frame(
  age_contrast = sub("^age_group","", names(beta)),
  SHR = exp(beta),
  LCL95 = exp(beta - 1.96*se),
  UCL95 = exp(beta + 1.96*se),
  p = 2*pnorm(abs(beta/se), lower.tail = FALSE)
)
cat("\nFine-Gray SHR (ref <=50):\n"); print(shr_tab, row.names = FALSE)

## 3) Score (LP) & Harrell-C
lp <- drop(X_age %*% beta)
t_mo <- df_cr$time_months 
e01 <- as.integer(df_cr$Status == 1) # binaire pour Harrell-C

ok <- is.finite(t_mo) & is.finite(lp) & is.finite(e01)
c_h <- survival::concordance(Surv(t_mo[ok], e01[ok]) ~ lp[ok], timefix = TRUE)
harrell_df <- data.frame(Harrell_C = unname(as.numeric(c_h$concordance)))
cat("\nHarrell's C (cause=1):\n"); print(harrell_df, row.names = FALSE)
 # Harrell_C  =  0.4067889
## 4) AUC dependant time  via timeROC (competing-risk)
times_m <- c(12, 36, 60) # horizons -months
times_m <- times_m[times_m <= max(t_mo, na.rm=TRUE)] 

## Check: number of events and at-risk per horizon
diag_tab <- sapply(times_m, function(tt) c(
  events = sum(df_cr$Status==1 & t_mo <= tt, na.rm=TRUE),
  at_risk= sum(t_mo >= tt, na.rm=TRUE)
))
cat("\n[Diag] Events/At-risk :\n"); print(diag_tab)

tr <- timeROC(T = t_mo, delta = df_cr$Status, cause = 1,
              marker = lp, times = times_m,
              weighting = "marginal", iid = FALSE)

##Robust extraction of AUCs according to the timeROC version
get_auc <- function(obj){
  if (!is.null(obj$AUC)) return(as.numeric(obj$AUC))
  if (!is.null(obj$AUC_1)) return(as.numeric(obj$AUC_1))
  if (!is.null(obj$AUC.t)) return(as.numeric(obj$AUC.t))
  rep(NA_real_, length(obj$times))
}
fg_auc <- data.frame(time_months = tr$times, AUC = get_auc(tr))

cat("\nAUC(t) Fine-Gray (months):\n"); print(fg_auc, row.names = FALSE)
 # AUC(t) Fine-Gray (months):
# time_months       AUC
#12 0.5824350
#36 0.6103838
#60 0.6457874
fg_auc <- subset(fg_auc, is.finite(time_months) & is.finite(AUC))
print(fg_auc); 
wcsv(fg_auc, "fg_timeROC_AUC.csv")

plot(fg_auc$time_months, fg_auc$AUC,
     type = "b", pch = 16, lwd = 2,
     xlab = "Follow-up (months)",
     ylab = "AUC (Fine-Gray)",
     ylim = c(0.5, 1))
graphics::grid(col = "gray90") 
title("Fine-Gray time-dependent AUC")
out_dir <- "T:/study4/Results_tables"
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

## Secure/filter objects before export
fg_auc <- subset(fg_auc, is.finite(time_months) & is.finite(AUC))
harrell_df <- as.data.frame(harrell_df)
names(harrell_df) <- "C_index"

## exports CSV
write.csv(fg_auc,
          file = file.path(out_dir, "fg_timeROC_AUC.csv"),
          row.names = FALSE)

write.csv(harrell_df,
          file = file.path(out_dir, "fg_HarrellC.csv"),
          row.names = FALSE)

###
suppressPackageStartupMessages({
  library(ggplot2); library(ggrepel); library(scales)
})

stopifnot(exists("fg_auc"), is.data.frame(fg_auc))

# 1)All in fraction form[0..1] (we will displayen %)
to_frac <- function(x){
  if (!is.numeric(x)) return(x)
  mx <- suppressWarnings(max(x, na.rm=TRUE))
  if (!is.finite(mx)) return(x)
  if (mx > 100) x <- x/10000 
  else if (mx > 1) x <- x/100 
  x
}
names(fg_auc)
library()
fg_auc <- within(fg_auc, {
  pred_f <- to_frac(pred)
  obs_f <- to_frac(obs)
  LCL_f <- to_frac(LCL)
  UCL_f <- to_frac(UCL)
  time_lab <- factor(time_months, levels=c(12,36,60),
                     labels=c("12 months","36 months","60 months"))
})
cal_plot <- subset(cal_plot, is.finite(pred_f) & is.finite(obs_f))

# 2) Common limits and 1:1 ratio
mmax <- suppressWarnings(max(cal_plot$pred_f, cal_plot$obs_f, na.rm=TRUE))
mmax <- min(1, max(0.01, mmax*1.1))

# 3) Plot
gg <- ggplot(cal_plot, aes(x=pred_f, y=obs_f)) +
  geom_abline(slope=1, intercept=0, linetype=2, linewidth=0.5, alpha=0.6) +
  geom_errorbar(aes(ymin=LCL_f, ymax=UCL_f), width=0, alpha=0.6) +
  geom_point(size=2.4) +
  ggrepel::geom_text_repel(aes(label=paste0("D", decile, "\n n=", n)),
                           size=2.6, max.overlaps=100,
                           box.padding=0.15, min.segment.length=0,
                           show.legend=FALSE) +
  scale_x_continuous(labels=label_percent(accuracy=0.1),
                     limits=c(0, mmax), breaks=pretty(c(0, mmax), 6)) +
  scale_y_continuous(labels=label_percent(accuracy=0.1),
                     limits=c(0, mmax), breaks=pretty(c(0, mmax), 6)) +
  coord_equal() +
  facet_wrap(~ time_lab, nrow=1) +
  labs(title="Fine-Gray calibration by deciles",
       x="Predicted CIF SCD", y="Observed CIF SCD") +
  theme_minimal(base_size=12) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_line(linewidth=0.25, colour="grey85"),
        strip.text = element_text(face="bold"),
        plot.title = element_text(face="bold"))
print(gg)
dev.off()
# =======================================================================================
#HL = calibration
# ====================================================================================
suppressPackageStartupMessages({
  library(riskRegression) # FGR + predictRisk
  library(cmprsk)
  library(prodlim)# cuminc/timepoints 
  library(ggplot2); library(ggrepel)
})

# 1) build df_cr 
if (!exists("df_cr")) {
  stopifnot(exists("df_handled_cc"), is.data.frame(df_handled_cc))
  canon <- c("<=50","51-65","66-75",">75")
  clean_age <- function(x){
    x <- trimws(as.character(x))
    x <- gsub("\u2264","<=",x); x <- gsub("\u2013|\u2014|–|—","-",x); x <- gsub("\\s+","",x)
    x[x %in% c("<=50","<=50y","<=50yrs","<=50years")] <- "<=50"
    x[x %in% c("51-65","51–65")] <- "51-65"
    x[x %in% c("66-75","66–75")] <- "66-75"
    x[grepl("^> ?75|^>=?76|\\b76\\+\\b", x)] <- ">75"
    factor(x, levels = canon)
  }
  
  stopifnot(all(c("ftime_mo_int","fstatus","age_group") %in% names(df_handled_cc)))
  df_cr <- within(df_handled_cc, {
    time_months <- as.numeric(ftime_mo_int) # en mois
    Status <- as.integer(fstatus) # 0/1/2
    age_group <- clean_age(age_group)
  })
  df_cr <- subset(df_cr, is.finite(time_months) & time_months > 0 &
                    Status %in% 0:2 & !is.na(age_group))
}

# 2) Créer fgr_fit si absent
if (!exists("fgr_fit") || !inherits(fgr_fit, "FGR")) {
  fg_form <- Hist(time_months, Status) ~ age_group
  fgr_fit <- FGR(formula = fg_form, data = df_cr, cause = 1)
}

dir.create("T:/study4/Results_tables", showWarnings = FALSE, recursive = TRUE)
saveRDS(fgr_fit, "T:/study4/Results_tables/fgr_fit_age_only.rds")

stopifnot(inherits(fgr_fit,"FGR"),
          all(c("time_months","Status") %in% names(df_cr)))

## ---- 1) Decile table at time t (in months)
calib_deciles <- function(fit, data, t, K=10){
  pr <- drop(predictRisk(fit, newdata=data, times=t)) # E = risque prédit(t)
  keep <- is.finite(pr) & is.finite(data$time_months) & !is.na(data$Status)
  pr <- pr[keep]; d <- data[keep, , drop=FALSE]
  if (!length(pr)) return(NULL)
  
  qs <- unique(quantile(pr, probs=seq(0,1,length.out=K+1), na.rm=TRUE))
  grp <- cut(pr, breaks=qs, include.lowest=TRUE, labels=paste0("D", seq_len(length(qs)-1)))
  if (nlevels(grp) < 2L) return(NULL)
  
  one_decile <- function(idx){
    id <- which(idx); n <- length(id)
    if (!n) return(data.frame(n=0,pred=NA,obs=NA,se=NA))
    pe <- mean(pr[id], na.rm=TRUE)
    
    ci <- cmprsk::cuminc(ftime=d$time_months[id], fstatus=d$Status[id], cencode=0)
    id1 <- grep(" 1$", names(ci))
    tp <- cmprsk::timepoints(ci, times=t)
    est <- try(tp$est[id1,1], silent=TRUE); est <- if (inherits(est,"try-error")) NA_real_ else as.numeric(est)
    se <- sqrt(pmax(est,0)*pmax(1-est,0)/max(n,1)) # var binomiale simple
    
    data.frame(n=n, pred=pe, obs=est, se=se)
  }
  
  tab <- by(seq_along(pr), grp, function(ii) one_decile(seq_along(pr) %in% ii))
  out <- do.call(rbind, tab)
  out$decile <- rownames(out); rownames(out) <- NULL
  out$time_months <- t
  transform(out,
            pred=100*pred,
            obs =100*obs,
            LCL =pmax(0, 100*(obs/100 - 1.96*se)),
            UCL =pmin(100,100*(obs/100 + 1.96*se)))[,c("time_months","decile","n","pred","obs","LCL","UCL")]
}

## ---- 2) tables at the 3 horizons
times_m <- c(12,36,60)
cal_list <- lapply(times_m, function(t) calib_deciles(fgr_fit, df_cr, t))
cal_all <- do.call(rbind, cal_list)

write.csv(subset(cal_all, time_months==12), "fg_calibration_deciles_12m.csv", row.names=FALSE)
write.csv(subset(cal_all, time_months==36), "fg_calibration_deciles_36m.csv", row.names=FALSE)
write.csv(subset(cal_all, time_months==60), "fg_calibration_deciles_60m.csv", row.names=FALSE)
write.csv(cal_all, "fg_calibration_deciles_all.csv", row.names=FALSE)

## ---- 3) HL-like (chi2 approximatif) by horizon
hl_like <- do.call(rbind, lapply(split(cal_all, cal_all$time_months), function(d){
  d <- subset(d, is.finite(pred) & is.finite(obs) & is.finite(n) & n>0)
  p <- d$pred/100; o <- d$obs/100; n <- d$n
  V <- p*(1-p)/pmax(n,1)
  chisq <- sum((o - p)^2 / pmax(V, 1e-12))
  G <- length(o)
  df <- max(G - 2L, 1L) # df ≈ G-2 (classic HL) – approximation
  data.frame(time_months = unique(d$time_months)[1],
             groups = G, chisq = chisq, df = df,
             p_value = pchisq(chisq, df=df, lower.tail=FALSE))
}))
print(hl_like, digits=4)
write.csv(hl_like, "fg_calibration_HL_like.csv", row.names=FALSE)
 # ===============================================================================================
#            Plot Calibration
# ================================================================================================
suppressPackageStartupMessages({library(ggplot2); library(ggrepel); library(scales)})

cal_plot <- subset(cal_all, is.finite(pred) & is.finite(obs) & is.finite(n) & n > 0)

if ("LCL" %in% names(cal_plot)) cal_plot$LCL <- pmax(0, cal_plot$LCL)
if ("UCL" %in% names(cal_plot)) cal_plot$UCL <- pmin(100, cal_plot$UCL)

if ("decile" %in% names(cal_plot) && is.numeric(cal_plot$decile)) {
  cal_plot$decile <- paste0("D", cal_plot$decile)
}

rng <- range(c(cal_plot$pred, cal_plot$obs), na.rm = TRUE)
rng <- c(0, max(2, ceiling(rng[2] * 1.10))) 

gg <- ggplot(cal_plot, aes(x = pred, y = obs)) +
  geom_abline(slope = 1, intercept = 0, linetype = 2, linewidth = 0.5, alpha = 0.7) +
  {if (all(c("LCL","UCL") %in% names(cal_plot)))
    geom_errorbar(aes(ymin = LCL, ymax = UCL), width = 0, alpha = 0.6)} +
  geom_point(aes(size = n), shape = 16, alpha = 0.9) +
  ggrepel::geom_text_repel(aes(label = decile),
                           size = 2.8, box.padding = 0.15,
                           min.segment.length = 0, max.overlaps = Inf, seed = 1) +
  coord_equal(xlim = rng, ylim = rng, expand = FALSE, clip = "off") +
  facet_wrap(~ time_months, nrow = 1,
             labeller = labeller(time_months = function(x) paste(x, "months"))) +
  scale_x_continuous("Predicted CIF SCD (%)", breaks = pretty(rng, 6)) +
  scale_y_continuous("Observed CIF SCD (%)", breaks = pretty(rng, 6)) +
  guides(size = guide_legend(title = "n", override.aes = list(alpha = 1))) +
  theme_minimal(base_size = 12) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_line(linewidth = 0.25, colour = "grey85"),
        strip.text = element_text(face = "bold"),
        plot.title = element_text(face = "bold"),
        legend.position = "bottom") +
  labs(title = "Fine-Gray calibration by deciles")

gg <- gg +
  guides(size = guide_legend(title = "n")) 
  scale_size_continuous(range = c(2.2, 6)) 
  theme(
    text = element_text(size = 12),
    strip.text = element_text(face = "bold"),
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(linewidth = 0.25, colour = "grey85")
  )
  fmt1 <- function(x) sub("\\.0$", "", sprintf("%.1f", x))
  
  gg <- gg +
    scale_x_continuous("Predicted CIF SCD (%)",
                       breaks = pretty(rng, 6),
                       labels = fmt1) +
    scale_y_continuous("Observed CIF SCD (%)",
                       breaks = pretty(rng, 6),
                       labels = fmt1)
  print(gg)
  
print(gg)
# ==============================================================================================================
# Validation internal : Bootstrap (n=1000)
# ==============================================================================================================
suppressPackageStartupMessages({
  library(riskRegression); library(survival); library(timeROC)
})
marker_at_t <- function(fit, data, t0=36){
  drop(predictRisk(fit, newdata=data, times=t0))
}
harrell_c_fg <- function(time_mo, status012, marker){
  ok <- is.finite(time_mo) & is.finite(marker) & status012 %in% 0:2
  if (!any(ok)) return(NA_real_)
  cc <- survival::concordance(Surv(time_mo[ok]/12, status012[ok]==1) ~ marker[ok], timefix=TRUE)
  as.numeric(unclass(cc$concordance))
}
safe_timeROC <- function(time_mo, status012, marker, times=c(12,36,60)){
  out <- setNames(rep(NA_real_, length(times)), paste0(times,"m"))
  times <- times[times <= max(time_mo, na.rm=TRUE)]
  if (!length(times)) return(out)
  tr <- try(timeROC::timeROC(T=time_mo, delta=status012, cause=1,
                             marker=marker, times=times,
                             iid=FALSE, weighting="marginal"), silent=TRUE)
  if (inherits(tr,"try-error")) return(out)
  auc <- if (!is.null(tr$AUC)) tr$AUC else if(!is.null(tr$AUC.t)) tr$AUC.t else tr$AUC_1
  names(auc) <- paste0(times,"m")
  out[names(auc)] <- as.numeric(auc); out
}

## ---- bootstrap (chunking)
fg_formula <- formula(fgr_fit)
times_eval <- c(12,36,60)
run_boot_fg <- function(B=10, seed=1, ckpt="fg_boot_ckpt.csv", out="fg_boot_summary.csv"){
  set.seed(seed)
  n <- nrow(df_cr)
  app_fit <- fgr_fit
  app_marker <- marker_at_t(app_fit, df_cr, t0=36)
  app_C <- harrell_c_fg(df_cr$time_months, df_cr$Status, app_marker)
  app_AUC <- safe_timeROC(df_cr$time_months, df_cr$Status, app_marker, times_eval)
  
  ##  checkpoint
  b_start <- 1L
  if (file.exists(ckpt)) {
    tmp <- try(read.csv(ckpt), silent=TRUE)
    if (!inherits(tmp,"try-error") && nrow(tmp)>0) b_start <- nrow(tmp)+1L
  }
  
  res <- if (b_start>1) tmp else data.frame(optC=numeric(0), optAUC12=numeric(0),
                                            optAUC36=numeric(0), optAUC60=numeric(0))
  
  pb <- utils::txtProgressBar(min=b_start-1, max=B, style=3)
  for (b in b_start:B){
    id <- sample.int(n, replace=TRUE)
    dB <- df_cr[id, , drop=FALSE]
    
    fitB <- try(FGR(fg_formula, data=dB, cause=1), silent=TRUE)
    if (inherits(fitB,"try-error")) { utils::setTxtProgressBar(pb,b); next }
    
    ## apparent "bootstrap"
    m_app <- marker_at_t(fitB, dB, t0=36)
    C_app <- harrell_c_fg(dB$time_months, dB$Status, m_app)
    A_app <- safe_timeROC(dB$time_months, dB$Status, m_app, times_eval)
    
    ## test on the original
    m_tst <- marker_at_t(fitB, df_cr, t0=36)
    C_tst <- harrell_c_fg(df_cr$time_months, df_cr$Status, m_tst)
    A_tst <- safe_timeROC(df_cr$time_months, df_cr$Status, m_tst, times_eval)
    
    res[b, c("optC","optAUC12","optAUC36","optAUC60")] <-
      c(C_app - C_tst,
        (A_app["12m"] - A_tst["12m"]),
        (A_app["36m"] - A_tst["36m"]),
        (A_app["60m"] - A_tst["60m"]))
    
    if (b %% 10L == 0L) write.csv(res, ckpt, row.names=FALSE) # checkpoint toutes les 10 itérations
    utils::setTxtProgressBar(pb,b)
  }
  close(pb); write.csv(res, ckpt, row.names=FALSE)
  
  mean_opt <- colMeans(res, na.rm=TRUE)
  out_tab <- data.frame(
    metric = c("HarrellC","AUC_12m","AUC_36m","AUC_60m"),
    apparent = c(app_C, unname(app_AUC[c("12m","36m","60m")])),
    optimism = unname(mean_opt[c("optC","optAUC12","optAUC36","optAUC60")]),
    optimism_corrected = c(app_C, unname(app_AUC[c("12m","36m","60m")])) -
      unname(mean_opt[c("optC","optAUC12","optAUC36","optAUC60")])
  )
  print(out_tab, digits=4)
  write.csv(out_tab, out, row.names=FALSE)
  invisible(out_tab)
}

run_boot_fg(B = 200, seed = 2025,
            ckpt = "fg_boot_ckpt_200.csv",
            out = "fg_boot_summary_200.csv")

run_boot_fg(B = 1000, seed = 2025,
            ckpt = "fg_boot_ckpt_1000.csv",
            out = "fg_boot_summary_1000.csv")
