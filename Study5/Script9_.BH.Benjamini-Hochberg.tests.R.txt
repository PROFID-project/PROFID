# ==============================================================================
# PROFID Study 5_Script 9 
# Benjamini–Hochberg (BH/FDR) adjustment for Script 5 hypothesis tests:
# 1) Joint interaction tests (Year×Age3, Year×LVEF_ESC, Year×DB)
# 2) Stratified Year-effect tests (Year effect within subgroups)
#
# Output: One XLSX workbook with BH-adjusted p-values (p_bh).
# ==============================================================================
suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(readr)
  library(readxl)
  library(openxlsx)
  library(tibble)
  library(purrr)
})

# USER EDIT: root folder
results_root <- "T:/Study_5/Results_Study5"

out_dir <- file.path(results_root, "Script9_Reporting")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

out_xlsx <- file.path(out_dir, "Study5_Script9_BH_from_Script5.xlsx")

#  Scope: GDMT ONLY 
accepted_outcomes <- c("GDMT_BIN_geq3", "GDMT_BIN_geq4")

# Helpers 

read_csv_all_char <- function(path) {
  readr::read_csv(
    path,
    show_col_types = FALSE,
    progress = FALSE,
    col_types = readr::cols(.default = readr::col_character())
  )
}

read_xlsx_all_char <- function(path, sheet = 1) {
  x <- readxl::read_xlsx(path, sheet = sheet)
  x %>% mutate(across(everything(), as.character))
}

read_any_table_all_char <- function(path) {
  ext <- tolower(tools::file_ext(path))
  if (ext == "csv") return(read_csv_all_char(path))
  if (ext %in% c("xlsx", "xls")) {
    sh <- readxl::excel_sheets(path)
    if (length(sh) == 0) return(tibble(error = "Empty workbook"))
    out <- lapply(sh, function(s) {
      y <- read_xlsx_all_char(path, sheet = s)
      y$.sheet <- s
      y
    })
    return(bind_rows(out))
  }
  tibble(error = paste0("Unsupported file type: ", ext))
}

detect_p_col <- function(nms) {
  cand <- c("p", "p_value", "pvalue", "p.value", "pval", "p_val",
            "pr(>chi)", "pr(>|z|)", "p-value", "pvalue_fm")
  low <- tolower(nms)
  hit <- intersect(low, cand)
  if (length(hit) == 0) return(NA_character_)
  nms[match(hit[1], low)]
}

parse_p_numeric <- function(x) {
  if (is.null(x)) return(rep(NA_real_, 0))
  x <- as.character(x)
  x <- str_trim(x)
  x <- str_replace_all(x, ",", ".")
  x <- str_replace_all(x, "^<\\s*", "")
  x <- str_replace_all(x, "^>\\s*", "")
  x <- na_if(x, "NA")
  x <- na_if(x, "")
  suppressWarnings(as.numeric(x))
}

extract_outcome_from_filename <- function(fn) {
  if (str_detect(fn, "GDMT_BIN_geq3")) return("GDMT_BIN_geq3")
  if (str_detect(fn, "GDMT_BIN_geq4")) return("GDMT_BIN_geq4")
  NA_character_
}

extract_label_from_path <- function(path) {
  basename(dirname(path))
}

extract_stratvar_from_filename <- function(fn) {
  m <- str_match(fn, "STRAT_pooled_OR_year_([^_]+)_")
  if (!is.na(m[1,2])) return(m[1,2])
  m2 <- str_match(fn, "STRAT_pooled_OR_year_(.*)_GDMT")
  if (!is.na(m2[1,2])) return(m2[1,2])
  NA_character_
}

safe_sheet_name <- function(x, existing = character(0)) {
  x <- str_replace_all(x, "[\\[\\]\\*\\?/\\\\:]", "_")
  x <- substr(x, 1, 31)
  if (!(tolower(x) %in% tolower(existing))) return(x)
  
  base <- substr(x, 1, 28)
  k <- 1
  repeat {
    cand <- paste0(base, "_", k)
    cand <- substr(cand, 1, 31)
    if (!(tolower(cand) %in% tolower(existing))) return(cand)
    k <- k + 1
  }
}

add_bh_columns <- function(df, family_id) {
  pcol <- detect_p_col(names(df))
  
  df$.p_raw <- if (is.na(pcol)) NA_character_ else df[[pcol]]
  df$.p_num <- parse_p_numeric(df$.p_raw)
  
  ok <- is.finite(df$.p_num)
  df$p_raw_for_bh <- df$.p_num
  df$p_bh <- NA_real_
  if (any(ok)) df$p_bh[ok] <- p.adjust(df$.p_num[ok], method = "BH")
  
  df$bh_family <- family_id
  df$bh_note <- if (is.na(pcol)) "No p-value column detected -> BH not applied" else NA_character_
  df
}
# =====================================================================================
# 1) Locate Script 5 outputs 
# ====================================================================================
# GDMT :  we keep only files that contain GDMT_BIN_geq3 or GDMT_BIN_geq4 in filename
joint_files <- list.files(
  results_root,
  pattern = "PRIMARY_MI_M5_joint_tests_.*GDMT_BIN_geq[34].*\\.(csv|xlsx)$",
  full.names = TRUE,
  recursive = TRUE,
  ignore.case = TRUE
)

strat_files <- list.files(
  results_root,
  pattern = "STRAT_pooled_OR_year_.*GDMT_BIN_geq[34].*\\.(csv|xlsx)$",
  full.names = TRUE,
  recursive = TRUE,
  ignore.case = TRUE
)
# ================================================================================
#  2) Read + BH adjust 
# ================================================================================
# A) Joint interaction tests:
# BH within each FILE (each file should contain the 3 joint tests)
jt_all <- tibble()
if (length(joint_files) > 0) {
  jt_all <- bind_rows(lapply(joint_files, function(f) {
    fn <- basename(f)
    x <- read_any_table_all_char(f)
    
    x$.source_path <- f
    x$.source_file <- fn
    x$.source_dir <- extract_label_from_path(f)
    x$.label <- extract_label_from_path(f)
    x$.outcome <- extract_outcome_from_filename(fn)
    
    # extra safety (should already be filtered by pattern)
    if (is.na(x$.outcome[1]) || !(x$.outcome[1] %in% accepted_outcomes)) {
      x$bh_note <- "Excluded (not GDMT outcome in scope)"
      return(x)
    }
    
    fam <- paste0("joint_tests|", x$.label[1], "|", x$.outcome[1], "|", fn)
    add_bh_columns(x, family_id = fam)
  })) %>%
    filter(.outcome %in% accepted_outcomes)
} else {
  jt_all <- tibble(message = "No PRIMARY_MI_M5_joint_tests_*GDMT_BIN_geq(3|4)* files found under results_root.")
}

# B) Stratified Year-effect tests:
# BH within each FILE (each file = one stratification analysis for one outcome/label)
sy_all <- tibble()
if (length(strat_files) > 0) {
  sy_all <- bind_rows(lapply(strat_files, function(f) {
    fn <- basename(f)
    x <- read_any_table_all_char(f)
    
    x$.source_path <- f
    x$.source_file <- fn
    x$.source_dir <- extract_label_from_path(f)
    x$.label <- extract_label_from_path(f)
    x$.outcome <- extract_outcome_from_filename(fn)
    x$.strat_var <- extract_stratvar_from_filename(fn)
    
    if (is.na(x$.outcome[1]) || !(x$.outcome[1] %in% accepted_outcomes)) {
      x$bh_note <- "Excluded (not GDMT outcome in scope)"
      return(x)
    }
    
    fam <- paste0("strat_year|", x$.label[1], "|", x$.outcome[1], "|", x$.strat_var[1], "|", fn)
    add_bh_columns(x, family_id = fam)
  })) %>%
    filter(.outcome %in% accepted_outcomes)
} else {
  sy_all <- tibble(message = "No STRAT_pooled_OR_year_*GDMT_BIN_geq(3|4)* files found under results_root.")
}
# =================================================================================
# 3) Indices + Summary 
# =================================================================================
files_index <- bind_rows(
  tibble(file_type = "joint_tests", path = joint_files),
  tibble(file_type = "stratified_year", path = strat_files)
)

bh_summary <- bind_rows(
  tibble(
    section = "Joint interaction tests (Script 5, GDMT only)",
    n_files_kept = length(unique(jt_all$.source_path)),
    n_p_detected = sum(is.finite(jt_all$p_raw_for_bh), na.rm = TRUE)
  ),
  tibble(
    section = "Stratified Year-effect tests (Script 5, GDMT only)",
    n_files_kept = length(unique(sy_all$.source_path)),
    n_p_detected = sum(is.finite(sy_all$p_raw_for_bh), na.rm = TRUE)
  )
)
# ====================================================================================
#  4) Write XLSX 
# ===================================================================================
wb <- openxlsx::createWorkbook()

openxlsx::addWorksheet(wb, "BH_Summary")
openxlsx::writeData(wb, "BH_Summary", bh_summary)

openxlsx::addWorksheet(wb, "Input_Files")
openxlsx::writeData(wb, "Input_Files", files_index)

openxlsx::addWorksheet(wb, "JT_All")
openxlsx::writeData(wb, "JT_All", jt_all)

openxlsx::addWorksheet(wb, "SY_All")
openxlsx::writeData(wb, "SY_All", sy_all)

existing <- names(wb)

if (nrow(jt_all) > 0 && any(!is.na(jt_all$.source_path))) {
  for (p in unique(jt_all$.source_path)) {
    fn <- basename(p)
    sh <- safe_sheet_name(paste0("JT_", str_replace(fn, "\\.(csv|xlsx)$", "")), existing)
    existing <- c(existing, sh)
    
    x <- jt_all %>% filter(.source_path == p)
    openxlsx::addWorksheet(wb, sh)
    openxlsx::writeData(wb, sh, x)
  }
}

if (nrow(sy_all) > 0 && any(!is.na(sy_all$.source_path))) {
  for (p in unique(sy_all$.source_path)) {
    fn <- basename(p)
    sh <- safe_sheet_name(paste0("SY_", str_replace(fn, "\\.(csv|xlsx)$", "")), existing)
    existing <- c(existing, sh)
    
    x <- sy_all %>% filter(.source_path == p)
    openxlsx::addWorksheet(wb, sh)
    openxlsx::writeData(wb, sh, x)
  }
}

openxlsx::saveWorkbook(wb, out_xlsx, overwrite = TRUE)
cat("[OK] BH reporting workbook saved to:", out_xlsx, "\n")
