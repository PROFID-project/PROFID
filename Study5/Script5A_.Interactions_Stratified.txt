# ==============================================================================
# UmBIZO_PROFID — Study 5
# Script 05A — PRIMARY analysis (COMPLETE-CASE) — 2000–2020
#
# Delivers (SAP Primary analyses on CC, aligned with prior scripts):
#  1) Main CC model (logistic regression) for primary outcome
#  2) Stratified analyses (Year effect within strata; SAP thresholds applied)
#  3) Predicted trends over time (2000–2020) with points + Wald 95% CI
#  4) Interaction joint tests (LRT; reduced vs full model)
#
# Cohort: HFrEF only (LVEF <40%) from Script 1 output df_study5_hfref.rds
# Window: 2000–2020
# Primary outcome: HF_BIN_eq3 (1 if HF therapy classes == 3)
#
# COMPLETE-CASE PRINCIPLE (PRIMARY ANALYSES):
# - All models in this script are fitted on complete-case rows only.
# - Sensitivity analyses using imputed data are handled in separate scripts(Script 5B).
#
# Notes:
# - DB is collapsed to top centres + OTHER; additionally, rare/event-sparse levels
#   are merged into OTHER to improve stability in stratified models/plots.
# - Stratified models and DB-plot models use strict diagnostics:
#   if warnings / non-convergence / separation are detected, we output a "clean"
#   row with NA estimates + a note (instead of unstable ORs).
# ==============================================================================

options(stringsAsFactors = FALSE)

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(readr)
  library(stringr)
  library(ggplot2)
  library(broom)
})

# ==============================================================================
# 0) CONFIG
# ==============================================================================
ROOT_DIR     <- "T:/Study_5"
RESULTS_ROOT <- file.path(ROOT_DIR, "Results_Study5")

IN_RDS  <- file.path(RESULTS_ROOT, "Script1_HFrEF_UPDATED", "df_study5_hfref.rds")
OUT_DIR <- file.path(RESULTS_ROOT, "Script5A_Primary_CC_2000_2020")
dir.create(OUT_DIR, recursive = TRUE, showWarnings = FALSE)

LABEL <- "HFrEF_PRIMARY_CC_2000_2020"

YEAR_MIN <- 2000L
YEAR_MAX <- 2020L

# Primary outcome (set ONE primary outcome here)
OUTCOME <- "HF_BIN_eq3"

# DB collapse for stability
TOP_DB_FOR_MODEL <- 8
TOP_DB_FOR_PLOTS <- 6

# SAP-style minimums for (a) stratified models and (b) plot models
MIN_N_STRAT      <- 200
MIN_EVENTS_STRAT <- 30

# ==============================================================================
# 1) Helpers
# ==============================================================================
log_line <- function(...) cat(format(Sys.time(), "%Y-%m-%d %H:%M:%S"), " | ", ..., "\n")

to_num01 <- function(x) {
  if (is.factor(x)) x <- as.character(x)
  if (is.logical(x)) return(as.integer(x))
  if (is.numeric(x)) return(ifelse(is.na(x), NA_integer_, as.integer(x != 0)))
  x2 <- tolower(trimws(as.character(x)))
  ifelse(is.na(x2), NA_integer_,
         ifelse(x2 %in% c("1","yes","y","true","t"), 1L,
                ifelse(x2 %in% c("0","no","n","false","f"), 0L, NA_integer_)))
}

fmt_p <- function(p) {
  p <- suppressWarnings(as.numeric(p))
  ifelse(is.na(p), NA_character_,
         ifelse(p < 0.001, "<0.001", formatC(p, format="f", digits=3)))
}

get_mode <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA)
  x <- as.character(x)
  names(sort(table(x), decreasing = TRUE))[1]
}

collapse_top_levels <- function(x, top_n = 8, other_label = "OTHER") {
  xx <- as.character(x)
  tab <- sort(table(xx), decreasing = TRUE)
  keep <- names(tab)[seq_len(min(top_n, length(tab)))]
  out <- ifelse(is.na(xx), NA_character_, ifelse(xx %in% keep, xx, other_label))
  droplevels(factor(out))
}

# merge levels with too few EVENTS into OTHER (helps avoid separation)
collapse_sparse_by_events <- function(df, var, outcome, min_events = 30, other_label = "OTHER") {
  if (!(var %in% names(df)) || !(outcome %in% names(df))) return(df)
  x <- as.character(df[[var]])
  y <- df[[outcome]]
  if (all(is.na(x))) return(df)
  ev_by <- tapply(y == 1, x, function(z) sum(z, na.rm = TRUE))
  ev_by[is.na(ev_by)] <- 0
  keep <- names(ev_by)[ev_by >= min_events]
  x2 <- ifelse(is.na(x), NA_character_, ifelse(x %in% keep, x, other_label))
  df[[var]] <- droplevels(factor(x2))
  df
}


# drop predictors that have <2 non-missing unique levels in the current subset
.drop_single_level_predictors <- function(df, vars) {
  out <- character(0)
  for (v in vars) {
    if (!v %in% names(df)) next
    x <- df[[v]]
    if (is.factor(x) || is.character(x) || is.logical(x)) {
      ux <- unique(na.omit(as.character(x)))
      if (length(ux) < 2) next
    }
    out <- c(out, v)
  }
  unique(out)
}

# robust binomial GLM wrappers 
# Strict: used for sparse strata / DB plots. Flags separation/non-convergence; returns ok=FALSE.
.safe_glm_binom_strict <- function(df, formula, outcome, min_n = MIN_N_STRAT, min_events = MIN_EVENTS_STRAT) {
  y <- df[[outcome]]
  n_cc <- nrow(df)
  n_events <- sum(y == 1, na.rm = TRUE)
  
  if (n_cc < min_n) {
    return(list(fit = NULL, ok = FALSE,
                note = sprintf("Too few CC rows (<%s)", min_n),
                n_cc = n_cc, n_events = n_events, warnings = character(0)))
  }
  if (n_events < min_events) {
    return(list(fit = NULL, ok = FALSE,
                note = sprintf("Too few events (<%s)", min_events),
                n_cc = n_cc, n_events = n_events, warnings = character(0)))
  }
  
  warn_msgs <- character(0)
  fit <- withCallingHandlers(
    tryCatch(glm(formula, data = df, family = binomial(), control = glm.control(maxit = 50)),
             error = function(e) e),
    warning = function(w) {
      warn_msgs <<- c(warn_msgs, conditionMessage(w))
      invokeRestart("muffleWarning")
    }
  )
  
  if (inherits(fit, "error")) {
    return(list(fit = NULL, ok = FALSE,
                note = paste0("glm failed: ", fit$message),
                n_cc = n_cc, n_events = n_events, warnings = warn_msgs))
  }
  
  # Convergence / separation heuristics
  warn_sep <- any(grepl("complete separation|quasi", warn_msgs, ignore.case = TRUE))
  warn_01  <- any(grepl("fitted probabilities.*0 or 1", warn_msgs, ignore.case = TRUE))
  
  # coefficient pathologies
  coef_bad <- any(!is.finite(coef(fit)))
  
  # absurd SEs (often near-separation)
  sm <- suppressWarnings(summary(fit)$coef)
  se_bad <- FALSE
  if (is.matrix(sm) && nrow(sm) > 0 && "Std. Error" %in% colnames(sm)) {
    se_bad <- any(is.infinite(sm[, "Std. Error"])) || any(sm[, "Std. Error"] > 20, na.rm = TRUE)
  }
  
  # Treat "fitted probabilities 0/1" as informational unless accompanied by pathologies
  sep_flag <- isFALSE(fit$converged) || warn_sep || coef_bad || se_bad
  
  if (sep_flag) {
    return(list(fit = fit, ok = FALSE,
                note = "glm unstable (non-convergence / separation)",
                n_cc = n_cc, n_events = n_events, warnings = warn_msgs))
  }
  
  return(list(fit = fit, ok = TRUE,
              note = ifelse(length(warn_msgs) > 0, paste(unique(warn_msgs), collapse = " | "), NA_character_),
              n_cc = n_cc, n_events = n_events, warnings = warn_msgs))
}

# Main: allows warnings (including "0 or 1") but stores them; only fails if error/non-converged.
.safe_glm_binom_main <- function(df, formula, outcome, min_n = 50, min_events = 10) {
  y <- df[[outcome]]
  n_cc <- nrow(df)
  n_events <- sum(y == 1, na.rm = TRUE)
  
  if (n_cc < min_n) {
    return(list(fit = NULL, ok = FALSE,
                note = sprintf("Too few CC rows (<%s)", min_n),
                n_cc = n_cc, n_events = n_events, warnings = character(0)))
  }
  if (n_events < min_events) {
    return(list(fit = NULL, ok = FALSE,
                note = sprintf("Too few events (<%s)", min_events),
                n_cc = n_cc, n_events = n_events, warnings = character(0)))
  }
  
  warn_msgs <- character(0)
  fit <- withCallingHandlers(
    tryCatch(glm(formula, data = df, family = binomial(), control = glm.control(maxit = 50)),
             error = function(e) e),
    warning = function(w) {
      warn_msgs <<- c(warn_msgs, conditionMessage(w))
      invokeRestart("muffleWarning")
    }
  )
  
  if (inherits(fit, "error")) {
    return(list(fit = NULL, ok = FALSE,
                note = paste0("glm failed: ", fit$message),
                n_cc = n_cc, n_events = n_events, warnings = warn_msgs))
  }
  
  if (isFALSE(fit$converged)) {
    return(list(fit = fit, ok = FALSE,
                note = "glm did not converge",
                n_cc = n_cc, n_events = n_events, warnings = warn_msgs))
  }
  
  # keep warnings as a NOTE, but do not block the main model
  note <- ifelse(length(warn_msgs) > 0, paste(unique(warn_msgs), collapse = " | "), NA_character_)
  return(list(fit = fit, ok = TRUE, note = note,
              n_cc = n_cc, n_events = n_events, warnings = warn_msgs))
}

.extract_or_year <- function(fit_obj, year_var = "Year_index") {
  sm <- suppressWarnings(summary(fit_obj)$coef)
  if (!is.matrix(sm) || !(year_var %in% rownames(sm))) return(NULL)
  b  <- sm[year_var, "Estimate"]
  se <- sm[year_var, "Std. Error"]
  p  <- sm[year_var, "Pr(>|z|)"]
  data.frame(
    OR_year = exp(b),
    OR_low  = exp(b - 1.96 * se),
    OR_high = exp(b + 1.96 * se),
    p_value = p,
    stringsAsFactors = FALSE
  )
}

safe_predict_link <- function(fit, newdata) {
  nd <- newdata
  if (!is.null(fit$xlevels)) {
    for (v in names(fit$xlevels)) {
      if (v %in% names(nd)) nd[[v]] <- factor(as.character(nd[[v]]), levels = fit$xlevels[[v]])
    }
  }
  pr <- tryCatch(predict(fit, newdata = nd, type = "link", se.fit = TRUE),
                 error = function(e) NULL)
  if (is.null(pr)) return(tibble(fit = NA_real_, se = NA_real_))
  tibble(fit = as.numeric(pr$fit), se = as.numeric(pr$se.fit))
}

# ==============================================================================
# 2) Load + harmonise
# ==============================================================================
stopifnot(file.exists(IN_RDS))
df <- readRDS(IN_RDS)
stopifnot(is.data.frame(df))
log_line("[INFO] Loaded: ", IN_RDS, " | n=", nrow(df), " p=", ncol(df))

# Year restriction 2000–2020
stopifnot("Year_index" %in% names(df))
df <- df %>%
  mutate(Year_index = suppressWarnings(as.numeric(as.character(Year_index)))) %>%
  filter(!is.na(Year_index), Year_index >= YEAR_MIN, Year_index <= YEAR_MAX)

# HFrEF only (defensive; Script1 should already have it)
if ("LVEF_num" %in% names(df)) {
  df <- df %>% filter(!is.na(LVEF_num), suppressWarnings(as.numeric(LVEF_num)) < 40)
} else if ("LVEF_ESC" %in% names(df)) {
  df <- df %>% filter(as.character(LVEF_ESC) == "<40%")
}

# Outcome
if (!(OUTCOME %in% names(df))) {
  cand <- c("HF_n_classes", "HF_GDMT_count4", "HF_classes_n", "HF_count", "HF_therapy_count")
  cnt <- cand[cand %in% names(df)]
  if (length(cnt) == 0) stop("Outcome HF_BIN_eq3 missing and no HF therapy count variable found.")
  hf_n <- suppressWarnings(as.numeric(as.character(df[[cnt[1]]])))
  df[[OUTCOME]] <- ifelse(is.na(hf_n), NA_integer_, as.integer(hf_n == 3))
} else {
  df[[OUTCOME]] <- to_num01(df[[OUTCOME]])
}

# Age & categories
if (!("Age_num" %in% names(df)) && ("Age" %in% names(df))) df$Age_num <- suppressWarnings(as.numeric(df$Age))
if ("Age_num" %in% names(df)) df$Age_num <- suppressWarnings(as.numeric(df$Age_num))
if (!("Age3" %in% names(df)) && "Age_num" %in% names(df)) {
  df$Age3 <- cut(df$Age_num, breaks = c(-Inf, 65, 75, Inf),
                 labels = c("<=65", "66-75", ">75"), right = TRUE)
}
if ("Age3" %in% names(df)) df$Age3 <- factor(as.character(df$Age3), levels = c("<=65","66-75",">75"))

# Binary harmonisation (keep as factors for model)
if ("Sex_BIN_Male" %in% names(df)) df$Sex_BIN_Male <- factor(as.character(to_num01(df$Sex_BIN_Male)), levels = c("0","1"))
if ("ICD_BIN_Yes" %in% names(df))  df$ICD_BIN_Yes  <- factor(as.character(to_num01(df$ICD_BIN_Yes)),  levels = c("0","1"))

# DB collapse for stability (top N) + merge event-sparse levels
if ("DB" %in% names(df)) {
  df$DB <- collapse_top_levels(df$DB, top_n = TOP_DB_FOR_MODEL, other_label = "OTHER")
  # merge any remaining event-sparse levels into OTHER
  df <- collapse_sparse_by_events(df, var = "DB", outcome = OUTCOME, min_events = MIN_EVENTS_STRAT, other_label = "OTHER")
  ref_db <- names(sort(table(df$DB), decreasing = TRUE))[1]
  if (!is.na(ref_db) && ref_db %in% levels(df$DB)) df$DB <- relevel(df$DB, ref = ref_db)
}

# Time period split (median year)
if (!("time_period" %in% names(df))) {
  cutv <- median(df$Year_index, na.rm = TRUE)
  df$time_period <- ifelse(df$Year_index <= cutv, "Early (<= median)", "Recent (> median)")
  df$time_period <- factor(df$time_period, levels = c("Early (<= median)", "Recent (> median)"))
}

log_line("[INFO] After filters: n=", nrow(df), " | Events=", sum(df[[OUTCOME]] == 1, na.rm = TRUE))

# ==============================================================================
# 3) Model specification (main effects + interactions to test)
# ==============================================================================
RHS_MAIN <- c(
  "Year_index",
  "Age3",
  "Sex_BIN_Male",
  "DB",
  "ICD_BIN_Yes",
  "Time_index_MI_CHD_log1p",
  "Diabetes_BIN_Yes",
  "Hypertension_BIN_Yes",
  "Smoking_BIN_Yes",
  "AF_atrial_flutter_BIN_Yes",
  "Stroke_TIA_BIN_Yes",
  "eGFR_log1p",
  "Haemoglobin_log1p",
  "PCI_BIN_Yes",
  "CABG_BIN_Yes",
  "Revascularisation_acute_BIN_Yes"
)
RHS_MAIN <- RHS_MAIN[RHS_MAIN %in% names(df)]
if (!("Year_index" %in% RHS_MAIN)) stop("Year_index missing after harmonisation.")

# Interactions for HFrEF-only analysis (no LVEF interaction here)
INTERACTIONS <- c("Year_index:Age3", "Year_index:DB")
INTERACTIONS <- INTERACTIONS[!is.na(INTERACTIONS)]

# ==============================================================================
# 4) COMPLETE-CASE dataset for modelling
# ==============================================================================
needed_for_any <- unique(c(OUTCOME, RHS_MAIN, unlist(strsplit(INTERACTIONS, ":", fixed = TRUE))))
needed_for_any <- needed_for_any[needed_for_any %in% names(df)]

df_cc_all <- df %>%
  select(all_of(needed_for_any)) %>%
  filter(complete.cases(.))

log_line("[INFO] Complete-case rows for modelling: n_cc=", nrow(df_cc_all),
         " | events=", sum(df_cc_all[[OUTCOME]] == 1, na.rm = TRUE))

write_csv(tibble(n_total = nrow(df), n_cc = nrow(df_cc_all),
                 events_total = sum(df[[OUTCOME]] == 1, na.rm = TRUE),
                 events_cc = sum(df_cc_all[[OUTCOME]] == 1, na.rm = TRUE)),
          file.path(OUT_DIR, "QC_CC_counts.csv"))

# ==============================================================================
# 5) MAIN CC MODEL
# ==============================================================================
MODELS_DIR <- file.path(OUT_DIR, "Models_CC")
dir.create(MODELS_DIR, recursive = TRUE, showWarnings = FALSE)

f_main <- as.formula(paste0(OUTCOME, " ~ ", paste(RHS_MAIN, collapse = " + ")))
main_res <- .safe_glm_binom_main(df_cc_all, f_main, outcome = OUTCOME, min_n = 50, min_events = 10)

if (!isTRUE(main_res$ok)) stop("Main CC model failed: ", main_res$note)

fit_main <- main_res$fit
saveRDS(fit_main, file.path(MODELS_DIR, paste0("PRIMARY_CC_model_", OUTCOME, ".rds")))

main_or <- broom::tidy(fit_main, conf.int = TRUE, exponentiate = TRUE) %>%
  filter(term != "(Intercept)") %>%
  mutate(p_value_fmt = fmt_p(p.value)) %>%
  select(term, estimate, conf.low, conf.high, p.value, p_value_fmt)

write_csv(main_or, file.path(MODELS_DIR, paste0("PRIMARY_CC_OR_", OUTCOME, ".csv")))

# store main-model warnings/note for transparency
write_csv(tibble(label = LABEL, outcome = OUTCOME,
                 note = ifelse(is.na(main_res$note), "", main_res$note),
                 n_cc = main_res$n_cc, n_events = main_res$n_events),
          file.path(MODELS_DIR, paste0("PRIMARY_CC_model_note_", OUTCOME, ".csv")))

log_line("[OK] Main CC model saved: ", MODELS_DIR)

# ==============================================================================
# 6) STRATIFIED ANALYSES (Year effect within strata; strict diagnostics)
# ==============================================================================
STRAT_DIR <- file.path(OUT_DIR, "Stratified_CC")
dir.create(STRAT_DIR, recursive = TRUE, showWarnings = FALSE)

df_cc_strat <- df_cc_all

# DB_plot for stratification/plots (collapsed more aggressively)
if ("DB" %in% names(df_cc_strat)) {
  df_cc_strat$DB_plot <- collapse_top_levels(df_cc_strat$DB, top_n = TOP_DB_FOR_PLOTS, other_label = "OTHER")
  df_cc_strat <- collapse_sparse_by_events(df_cc_strat, var = "DB_plot", outcome = OUTCOME, min_events = MIN_EVENTS_STRAT, other_label = "OTHER")
  ref_db2 <- names(sort(table(df_cc_strat$DB_plot), decreasing = TRUE))[1]
  if (!is.na(ref_db2) && ref_db2 %in% levels(df_cc_strat$DB_plot)) df_cc_strat$DB_plot <- relevel(df_cc_strat$DB_plot, ref = ref_db2)
}

strat_vars <- c("ICD_BIN_Yes", "Age3", "time_period", "DB_plot")
strat_vars <- strat_vars[strat_vars %in% names(df_cc_strat)]

fit_year_in_stratum <- function(d, strat_var, level) {
  dd <- d[d[[strat_var]] == level, , drop = FALSE]
  
  out <- tibble(
    outcome = OUTCOME,
    strat_var = strat_var,
    level = as.character(level),
    n_cc = nrow(dd),
    n_events = sum(dd[[OUTCOME]] == 1, na.rm = TRUE),
    OR_year = NA_real_,
    OR_low = NA_real_,
    OR_high = NA_real_,
    p_value = NA_real_,
    p_value_fmt = NA_character_,
    note = NA_character_
  )
  
  rhs <- setdiff(RHS_MAIN, strat_var)
  
  # If stratifying by DB, ensure no DB term remains in the model.
  if (strat_var %in% c("DB", "DB_plot")) rhs <- setdiff(rhs, c("DB", "DB_plot"))
  
  rhs <- rhs[rhs %in% names(dd)]
  rhs <- .drop_single_level_predictors(dd, rhs)
  
  # ensure Year is included
  rhs <- unique(c("Year_index", setdiff(rhs, "Year_index")))
  
  f <- as.formula(paste0(OUTCOME, " ~ ", paste(rhs, collapse = " + ")))
  
  res <- .safe_glm_binom_strict(dd, f, outcome = OUTCOME,
                                min_n = MIN_N_STRAT, min_events = MIN_EVENTS_STRAT)
  
  out$n_cc <- res$n_cc
  out$n_events <- res$n_events
  out$note <- res$note
  
  if (isTRUE(res$ok)) {
    or_year <- .extract_or_year(res$fit, year_var = "Year_index")
    if (!is.null(or_year)) {
      out$OR_year <- or_year$OR_year[1]
      out$OR_low  <- or_year$OR_low[1]
      out$OR_high <- or_year$OR_high[1]
      out$p_value <- or_year$p_value[1]
      out$p_value_fmt <- fmt_p(or_year$p_value[1])
      out$note <- ifelse(is.na(res$note), NA_character_, res$note)
    } else {
      out$note <- "Year_index term missing"
    }
  }
  
  out
}

for (sv in strat_vars) {
  levs <- df_cc_strat[[sv]]
  levs <- if (is.factor(levs)) levels(levs) else sort(unique(levs))
  levs <- levs[!is.na(levs)]
  
  out_tbl <- bind_rows(lapply(levs, function(lv) fit_year_in_stratum(df_cc_strat, sv, lv)))
  write_csv(out_tbl, file.path(STRAT_DIR, paste0("STRAT_OR_year_", sv, "_", OUTCOME, ".csv")), na = "")
}

log_line("[OK] Stratified outputs written: ", STRAT_DIR)

# ==============================================================================
# 7) PREDICTED TRENDS 2000–2020 
# ==============================================================================
PRED_DIR <- file.path(OUT_DIR, "PredTrends_CC")
dir.create(PRED_DIR, recursive = TRUE, showWarnings = FALSE)

ref <- list()
for (v in RHS_MAIN) {
  if (!v %in% names(df_cc_all)) next
  if (is.factor(df_cc_all[[v]]) || is.character(df_cc_all[[v]])) ref[[v]] <- get_mode(df_cc_all[[v]])
  else ref[[v]] <- median(df_cc_all[[v]], na.rm = TRUE)
}
if ("Age3" %in% names(df_cc_all)) ref$Age3 <- "66-75"
if ("Sex_BIN_Male" %in% names(df_cc_all)) ref$Sex_BIN_Male <- "0"
if ("ICD_BIN_Yes" %in% names(df_cc_all))  ref$ICD_BIN_Yes  <- "0"
if ("DB" %in% names(df_cc_all))           ref$DB           <- get_mode(df_cc_all$DB)

year_seq <- seq(YEAR_MIN, YEAR_MAX, by = 1)

plot_pred <- function(dat, title_suffix) {
  ggplot(dat, aes(x = Year_index, y = pred, color = group, fill = group)) +
    geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.15, color = NA) +
    geom_line(linewidth = 1) +
    geom_point(size = 1.2) +
    labs(
      title = paste0("Predicted probability over time: ", OUTCOME, " by ", title_suffix, " (CC)"),
      x = "Calendar year",
      y = "Predicted probability",
      caption = "Complete-case glm; ribbon: Wald 95% CI on link scale."
    ) +
    guides(fill = "none")
}

skipped_plots <- tibble(section = character(0), group = character(0), reason = character(0))

# --- By Age3 (uses main model)
if ("Age3" %in% names(df_cc_all)) {
  groups <- levels(df_cc_all$Age3)
  nd <- tidyr::expand_grid(Year_index = year_seq, group = groups) %>%
    mutate(Year_index = as.numeric(Year_index),
           Age3 = group)
  
  for (nm in names(ref)) if (!nm %in% names(nd)) nd[[nm]] <- ref[[nm]]
  for (nm in names(nd)) if (nm %in% names(df_cc_all) && is.factor(df_cc_all[[nm]]))
    nd[[nm]] <- factor(as.character(nd[[nm]]), levels = levels(df_cc_all[[nm]]))
  
  pr <- safe_predict_link(fit_main, nd)
  z <- 1.96
  pred_age <- bind_cols(nd, pr) %>%
    mutate(lo_link = fit - z*se, hi_link = fit + z*se,
           pred = plogis(fit), lo = plogis(lo_link), hi = plogis(hi_link)) %>%
    select(Year_index, group, pred, lo, hi)
  
  write_csv(pred_age, file.path(PRED_DIR, paste0("pred_trends_Age3_", OUTCOME, "_CC.csv")))
  g <- plot_pred(pred_age, "Age3")
  ggsave(file.path(PRED_DIR, paste0("pred_trends_Age3_", OUTCOME, "_CC.png")), g, width = 10, height = 6, dpi = 300)
}

# --- By DB (fit a DB_plot model; strict diagnostics; skip if unstable)
if ("DB_plot" %in% names(df_cc_strat)) {
  
  rhs_plot <- RHS_MAIN[RHS_MAIN %in% names(df_cc_strat)]
  rhs_plot <- setdiff(rhs_plot, "DB")
  rhs_plot <- unique(c(rhs_plot, "DB_plot"))
  
  df_plot <- df_cc_strat %>%
    select(all_of(unique(c(OUTCOME, rhs_plot)))) %>%
    filter(complete.cases(.))
  
  f_plot <- as.formula(paste0(OUTCOME, " ~ ", paste(rhs_plot, collapse = " + ")))
  plot_res <- .safe_glm_binom_strict(df_plot, f_plot, outcome = OUTCOME,
                                     min_n = MIN_N_STRAT, min_events = MIN_EVENTS_STRAT)
  
  if (!isTRUE(plot_res$ok)) {
    skipped_plots <- bind_rows(skipped_plots,
                               tibble(section = "PredTrends_DB", group = "ALL", reason = plot_res$note))
    write_csv(tibble(message = "DB_plot model unstable; skipping DB predicted trends.",
                     note = plot_res$note,
                     n_cc = plot_res$n_cc, n_events = plot_res$n_events),
              file.path(PRED_DIR, paste0("pred_trends_DB_", OUTCOME, "_CC_SKIPPED.csv")))
  } else {
    
    fit_plot <- plot_res$fit
    
    ref2 <- list()
    for (v in rhs_plot) {
      if (!v %in% names(df_plot)) next
      if (is.factor(df_plot[[v]]) || is.character(df_plot[[v]])) ref2[[v]] <- get_mode(df_plot[[v]])
      else ref2[[v]] <- median(df_plot[[v]], na.rm = TRUE)
    }
    if ("Age3" %in% names(df_plot)) ref2$Age3 <- "66-75"
    if ("Sex_BIN_Male" %in% names(df_plot)) ref2$Sex_BIN_Male <- "0"
    if ("ICD_BIN_Yes" %in% names(df_plot))  ref2$ICD_BIN_Yes  <- "0"
    if ("DB_plot" %in% names(df_plot))      ref2$DB_plot      <- get_mode(df_plot$DB_plot)
    
    tt <- sort(table(as.character(df_plot$DB_plot)), decreasing = TRUE)
    groups <- names(tt)[seq_len(min(TOP_DB_FOR_PLOTS, length(tt)))]
    
    nd <- tidyr::expand_grid(Year_index = year_seq, group = groups) %>%
      mutate(Year_index = as.numeric(Year_index),
             DB_plot = group)
    
    for (nm in names(ref2)) if (!nm %in% names(nd)) nd[[nm]] <- ref2[[nm]]
    for (nm in names(nd)) if (nm %in% names(df_plot) && is.factor(df_plot[[nm]]))
      nd[[nm]] <- factor(as.character(nd[[nm]]), levels = levels(df_plot[[nm]]))
    
    pr <- safe_predict_link(fit_plot, nd)
    z <- 1.96
    pred_db <- bind_cols(nd, pr) %>%
      mutate(lo_link = fit - z*se, hi_link = fit + z*se,
             pred = plogis(fit), lo = plogis(lo_link), hi = plogis(hi_link)) %>%
      select(Year_index, group, pred, lo, hi)
    
    write_csv(pred_db, file.path(PRED_DIR, paste0("pred_trends_DB_", OUTCOME, "_CC.csv")))
    g <- plot_pred(pred_db, "DB")
    ggsave(file.path(PRED_DIR, paste0("pred_trends_DB_", OUTCOME, "_CC.png")), g, width = 10, height = 6, dpi = 300)
  }
}

if (nrow(skipped_plots) > 0) {
  write_csv(skipped_plots, file.path(PRED_DIR, "skipped_plots.csv"))
}

log_line("[OK] Predicted trends written: ", PRED_DIR)

# ==============================================================================
# 8) INTERACTION JOINT TESTS (LRT on CC; reduced vs full)
# ==============================================================================
INT_DIR <- file.path(OUT_DIR, "InteractionJointTests_CC")
dir.create(INT_DIR, recursive = TRUE, showWarnings = FALSE)

safe_glm_basic <- function(formula, data) {
  tryCatch(glm(formula, family = binomial(), data = data, control = glm.control(maxit = 50)),
           error = function(e) e)
}
ok_fit <- function(fit) inherits(fit, "glm") && isTRUE(fit$converged) && any(is.finite(coef(fit)))

lrt_joint <- function(data_cc, interaction_term) {
  parts <- strsplit(interaction_term, ":", fixed = TRUE)[[1]]
  v1 <- parts[1]; v2 <- parts[2]
  
  if (!(v1 %in% names(data_cc) && v2 %in% names(data_cc))) {
    return(tibble(
      section = "InteractionTests",
      label = LABEL,
      outcome = OUTCOME,
      interaction = interaction_term,
      test = "LRT",
      statistic = NA_real_,
      df = NA_real_,
      p_value = NA_real_,
      p_value_fmt = NA_character_,
      note = "Skipped: interaction variables not found in CC df",
      n_cc = nrow(data_cc),
      n_events = sum(data_cc[[OUTCOME]] == 1, na.rm = TRUE),
      formula_reduced = NA_character_,
      formula_full = NA_character_
    ))
  }
  
  base_ok <- RHS_MAIN[RHS_MAIN %in% names(data_cc)]
  f_red <- as.formula(paste0(OUTCOME, " ~ ", paste(base_ok, collapse = " + ")))
  f_full <- update(f_red, paste(". ~ . +", paste0(v1, "*", v2)))
  
  fit_red  <- safe_glm_basic(f_red,  data_cc)
  fit_full <- safe_glm_basic(f_full, data_cc)
  
  if (!ok_fit(fit_red) || !ok_fit(fit_full)) {
    return(tibble(
      section = "InteractionTests",
      label = LABEL,
      outcome = OUTCOME,
      interaction = interaction_term,
      test = "LRT",
      statistic = NA_real_,
      df = NA_real_,
      p_value = NA_real_,
      p_value_fmt = NA_character_,
      note = "Model fitting failed (glm error / non-convergence)",
      n_cc = nrow(data_cc),
      n_events = sum(data_cc[[OUTCOME]] == 1, na.rm = TRUE),
      formula_reduced = deparse(f_red),
      formula_full = deparse(f_full)
    ))
  }
  
  a <- anova(fit_red, fit_full, test = "Chisq")
  stat <- as.numeric(a$Deviance[2])
  df_diff <- as.numeric(a$Df[2])
  p <- as.numeric(a$`Pr(>Chi)`[2])
  
  tibble(
    section = "InteractionTests",
    label = LABEL,
    outcome = OUTCOME,
    interaction = interaction_term,
    test = "LRT",
    statistic = stat,
    df = df_diff,
    p_value = p,
    p_value_fmt = fmt_p(p),
    note = NA_character_,
    n_cc = nrow(data_cc),
    n_events = sum(data_cc[[OUTCOME]] == 1, na.rm = TRUE),
    formula_reduced = deparse(f_red),
    formula_full = deparse(f_full)
  )
}

int_res <- bind_rows(lapply(INTERACTIONS, function(it) lrt_joint(df_cc_all, it)))
write_csv(int_res, file.path(INT_DIR, paste0("joint_tests_", LABEL, "_", OUTCOME, ".csv")), na = "")
write_csv(int_res, file.path(INT_DIR, paste0("joint_tests_", LABEL, "_ALL.csv")), na = "")

sum_tab <- int_res %>%
  group_by(outcome, interaction) %>%
  summarise(
    n_tests = n(),
    n_ok = sum(is.na(note) & is.finite(p_value), na.rm = TRUE),
    n_skipped = sum(!is.na(note), na.rm = TRUE),
    p_min = suppressWarnings(min(p_value, na.rm = TRUE)),
    .groups = "drop"
  )
write_csv(sum_tab, file.path(INT_DIR, "JointTests_Summary.csv"), na = "")

log_line("[OK] Interaction joint tests written: ", INT_DIR)
log_line("[DONE] Script 05A PRIMARY CC completed. Outputs in: ", OUT_DIR)
