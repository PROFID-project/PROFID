################################################################################
# PROFID — Study 5 (Update)
# Script 1: Build analysis dataset (HFrEF only) + Calendar time + HF therapy counts
# Author : Amina Boudamaana
#
# Purpose :
# Starting from df_handled.rds (Study 4 harmonised + QC data),
# build the Study 5 analysis dataset for:
#
# "Temporal Trends and Determinants of Evidence-Based HF Therapy
# in Post-MI Patients" (SAP v2.0, updated with ESC HF guidelines).
#
# ====================================================================================
# Core decisions implemented:
# - Restrict to HFrEF only: LVEF < 40%
# - HF therapy classes counted (disease-modifying): RAAS (ACEi/ARB; OR ARNI if available), beta-blocker, MRA
# - SGLT2i: audited only (expected absent)
# - HF therapy count reported as 0/1/2/3 (since max observed = 3 in the extract)
# - Loop diuretics: reported descriptively (proxy variable "Diuretics" in harmonised extract)
# Outputs (CSV + RDS):
# - cohort_flow.csv
# - year_audit.csv
# - hf_endpoint_audit.csv
# - hf_endpoint_distribution.csv (3-level grouped: 0, 1–2, 3+) 
# - hf_endpoint_distribution_count4.csv (4-level count: 0, 1, 2, 3) 
# - df_study5_hfref.rds
# ====================================================================================
suppressPackageStartupMessages({
  library(dplyr)
  library(readr)
  library(stringr)
  library(tibble)
})
# ====================================================================================
# 0) Paths
# ====================================================================================
ROOT_DIR <- "T:/Study_5"

INPUT_CANDIDATES <- c(
  file.path(ROOT_DIR, "df_handled.rds"),
  file.path(ROOT_DIR, "df_study5.rds")
)

OUT_DIR <- file.path(ROOT_DIR, "Results_Study5", "Script1_HFrEF_UPDATED")
dir.create(OUT_DIR, recursive = TRUE, showWarnings = FALSE)

log_line <- function(...) cat(paste0(..., "\n"))

# ====================================================================================
# 1) Helpers
# ====================================================================================
pick_first_by_regex <- function(nm, patterns) {
  nm_l <- tolower(nm)
  for (pat in patterns) {
    hit <- which(str_detect(nm_l, pat))
    if (length(hit) > 0) return(nm[hit[1]])
  }
  NA_character_
}

safe_get <- function(df, col) {
  if (is.na(col) || !(col %in% names(df))) return(rep(NA, nrow(df)))
  df[[col]]
}

to_bin01 <- function(x) {
  # Robust binarisation for common encodings: 0/1, TRUE/FALSE, yes/no, present/absent
  if (is.logical(x)) return(as.integer(x))
  if (is.numeric(x)) return(as.integer(x > 0))
  xx <- tolower(as.character(x))
  as.integer(xx %in% c("1", "y", "yes", "true", "t", "present"))
}

as_num_safely <- function(x) suppressWarnings(as.numeric(as.character(x)))

read_best_input <- function(candidates) {
  existing <- candidates[file.exists(candidates)]
  if (length(existing) == 0) stop("No input RDS found. Checked:\n", paste(candidates, collapse = "\n"))
  # Prefer df_handled if present
  existing[1]
}

derive_year_index <- function(df) {
  nm <- names(df)
  
  # Prefer explicit year_index; then Time_zero_Y; then Time_zero_Ym (YYYYMM)
  col_year <- pick_first_by_regex(nm, c(
    "^year_index$", "^time_zero_y$", "calendar_year", "\\byear\\b"
  ))
  col_ym <- pick_first_by_regex(nm, c(
    "^time_zero_ym$", "^time_zero_ym\\b", "yearmonth", "\\bym\\b"
  ))
  
  yr <- rep(NA_integer_, nrow(df))
  src <- NA_character_
  
  if (!is.na(col_year)) {
    raw <- safe_get(df, col_year)
    yr_try <- suppressWarnings(as.integer(raw))
    
    # If stored as YYYYMM or character, take first 4 chars
    if (all(is.na(yr_try))) {
      rawc <- as.character(raw)
      yr_try <- suppressWarnings(as.integer(substr(rawc, 1, 4)))
    }
    
    yr <- yr_try
    src <- col_year
    
  } else if (!is.na(col_ym)) {
    raw <- as.character(safe_get(df, col_ym))
    yr <- suppressWarnings(as.integer(substr(raw, 1, 4)))
    src <- col_ym
  }
  
  list(year_index = yr, source = src, col_year = col_year, col_ym = col_ym)
}

make_period_bins <- function(y) {
  # Narrative centred on ~2000–2020
  cut(
    y,
    breaks = c( 1999, 2004, 2009, 2014, 2020),
    labels = c("2000–2004", "2005–2009", "2010–2014", "2015–2020"),
    right = TRUE
  )
}

# ====================================================================================
# 2) Load input
# ====================================================================================
IN_PATH <- read_best_input(INPUT_CANDIDATES)
df0 <- readRDS(IN_PATH)
stopifnot(is.data.frame(df0))

log_line("[INFO] Loaded: ", IN_PATH)
log_line("[INFO] Input dimensions: ", nrow(df0), " x ", ncol(df0))
   # dimensions: 139915 x 107
nm <- names(df0)

# ====================================================================================
# 3) Variable mapping (flexible)
# ====================================================================================
# LVEF
col_lvef <- pick_first_by_regex(nm, c("^lvef$", "\\blvef\\b", "lvef_num", "lvef_pct", "lvef_percent"))

# Database/site
col_db <- pick_first_by_regex(nm, c("^db$", "\\bdb\\b", "database", "site", "centre", "center"))

# Disease-modifying HF therapy classes
col_acei_arb <- pick_first_by_regex(nm, c(
  "ace_inhibitor_arb", "acei_arb", "ace.*arb", "ace[_ -]*inhib", "\\barb\\b", "\\bacei\\b"
))
col_bb <- pick_first_by_regex(nm, c("beta_blockers", "beta[_ -]*block", "\\bbb\\b", "bb[_ -]*bin"))
col_mra <- pick_first_by_regex(nm, c("aldosterone_antagonist", "\\bmra\\b", "mineralocorticoid", "spiron", "epleren"))

# Optional / audit only
col_arni <- pick_first_by_regex(nm, c("\\barni\\b", "sacubitril", "valsartan"))
col_sglt2 <- pick_first_by_regex(nm, c("\\bsglt2\\b", "dapag", "empag", "canag", "ertug"))

# Diuretics (descriptive only; proxy in harmonised extract)
# The stacked extract usually contains a single "Diuretics" yes/no rather than drug-specific columns.
col_diur <- pick_first_by_regex(nm, c("^diuretics$", "\\bdiuretic\\b", "^diur"))

# (Optional) attempt drug-specific loop diuretics if ever present (most likely absent in stacked extract)
col_furo <- pick_first_by_regex(nm, c("furosemide", "frusemide"))
col_tora <- pick_first_by_regex(nm, c("torasemide"))
col_bume <- pick_first_by_regex(nm, c("bumetanide"))
col_etha <- pick_first_by_regex(nm, c("ethacryn"))

log_line("[INFO] Variable mapping:")
log_line(" LVEF: ", col_lvef)
log_line(" DB/Site: ", ifelse(is.na(col_db), "<not found>", col_db))
log_line(" ACEi/ARB: ", col_acei_arb)
log_line(" Beta-blocker: ", col_bb)
log_line(" MRA: ", col_mra)
log_line(" ARNI (optional): ", ifelse(is.na(col_arni), "<not found>", col_arni))
log_line(" SGLT2 (audit): ", ifelse(is.na(col_sglt2), "<not found>", col_sglt2))
log_line(" Diuretics (descriptive): ", ifelse(is.na(col_diur), "<not found>", col_diur))
log_line(" Loop diuretics (drug-specific check): furo=", ifelse(is.na(col_furo), "<none>", col_furo),
         " | tora=", ifelse(is.na(col_tora), "<none>", col_tora),
         " | bume=", ifelse(is.na(col_bume), "<none>", col_bume),
         " | etha=", ifelse(is.na(col_etha), "<none>", col_etha))

stopifnot(!is.na(col_lvef), !is.na(col_acei_arb), !is.na(col_bb), !is.na(col_mra))

# ====================================================================================
# 4) Calendar year
# ====================================================================================
# --- Derive year + HARD restriction to analysis window: 2000–2020
yr <- derive_year_index(df0)

df0 <- df0 %>%
  mutate(
    Year_index = suppressWarnings(as.integer(yr$year_index)),
    Year_source = yr$source
  ) %>%
  filter(!is.na(Year_index), Year_index >= 2000L, Year_index <= 2020L)

# Period bins within 2000–2020
make_period_bins <- function(y) {
  cut(
    y,
    breaks = c(1999, 2004, 2009, 2014, 2020),
    labels = c("2000–2004", "2005–2009", "2010–2014", "2015–2020"),
    right = TRUE,
    include.lowest = TRUE
  )
}

df0$Period_2000_2020 <- make_period_bins(df0$Year_index)

year_audit <- tibble(
  n = nrow(df0),
  year_source = as.character(yr$source),
  year_min = min(df0$Year_index, na.rm = TRUE),
  year_max = max(df0$Year_index, na.rm = TRUE),
  year_missing = sum(is.na(df0$Year_index))
)
write_csv(year_audit, file.path(OUT_DIR, "year_audit.csv"))
# ====================================================================================
# 5) Build base dataset + HFrEF restriction
# ====================================================================================
df <- df0 %>%
  mutate(
    LVEF_num = as_num_safely(.data[[col_lvef]]),
    DB = if (!is.na(col_db)) as.factor(.data[[col_db]]) else factor(rep("ALL", n())),
    ACEI_ARB = to_bin01(.data[[col_acei_arb]]),
    BB = to_bin01(.data[[col_bb]]),
    MRA = to_bin01(.data[[col_mra]]),
    ARNI = if (!is.na(col_arni)) to_bin01(.data[[col_arni]]) else NA_integer_,
    SGLT2 = if (!is.na(col_sglt2)) to_bin01(.data[[col_sglt2]]) else NA_integer_,
    Diuretics = if (!is.na(col_diur)) to_bin01(.data[[col_diur]]) else NA_integer_,
    # drug-specific loop diuretics (if present) — descriptive only
    LoopDiuretic_drug_specific = {
      have_any <- !is.na(col_furo) || !is.na(col_tora) || !is.na(col_bume) || !is.na(col_etha)
      if (!have_any) {
        NA_integer_
      } else {
        as.integer(
          (to_bin01(safe_get(df0, col_furo)) == 1) |
            (to_bin01(safe_get(df0, col_tora)) == 1) |
            (to_bin01(safe_get(df0, col_bume)) == 1) |
            (to_bin01(safe_get(df0, col_etha)) == 1)
        )
      }
    }
  )

n0 <- nrow(df)
n_lvef <- sum(!is.na(df$LVEF_num))

df_hfref <- df %>% filter(!is.na(LVEF_num) & LVEF_num < 40)
n_hfref <- nrow(df_hfref)

flow_tbl <- tibble(
  step = c("Input dataset", "Non-missing LVEF", "HFrEF restriction (LVEF <40%)"),
  n = c(n0, n_lvef, n_hfref)
)
write_csv(flow_tbl, file.path(OUT_DIR, "cohort_flow.csv"))
log_line("[OK] Wrote cohort_flow.csv")

# ====================================================================================
# 6) Define HF therapy endpoint (count-based)
# ====================================================================================
# NOTE:
# - RAAS counted as ACEi/ARB; OR ARNI if ARNI exists and is non-missing.
# - SGLT2 is audited only (expected absent).
# - Diuretics reported descriptively only (proxy; not part of disease-modifying count).

df_hfref <- df_hfref %>%
  mutate(
    RAAS = case_when(
      !is.na(ARNI) ~ as.integer((ACEI_ARB == 1) | (ARNI == 1)),
      TRUE ~ as.integer(ACEI_ARB == 1)
    ),
    HF_n_classes = RAAS + BB + MRA, # expected range 0–3
    HF_n_classes = pmin(pmax(HF_n_classes, 0L), 3L) # clamp for safety
    
  ) %>%
  mutate(
    # 4-level count (report-friendly)
    HF_GDMT_count4 = factor(as.character(HF_n_classes), levels = c("0", "1", "2", "3")),
    
    # 3-level grouped category (pipeline-friendly; avoids Excel date conversion using en-dash)
    HF_GDMT_cat_display = case_when(
      HF_n_classes == 0 ~ "0",
      HF_n_classes %in% c(1, 2) ~ "1–2",
      HF_n_classes == 3 ~ "3+",
      TRUE ~ NA_character_
    ),
    HF_GDMT_cat = factor(HF_GDMT_cat_display, levels = c("0", "1–2", "3+"))
  )

# Endpoint audit
audit <- tibble(
  n = nrow(df_hfref),
  
  pct_RAAS_1 = mean(df_hfref$RAAS == 1, na.rm = TRUE),
  pct_BB_1 = mean(df_hfref$BB == 1, na.rm = TRUE),
  pct_MRA_1 = mean(df_hfref$MRA == 1, na.rm = TRUE),
  
  arni_nonmissing_rate = mean(!is.na(df_hfref$ARNI)),
  sglt2_nonmissing_rate = mean(!is.na(df_hfref$SGLT2)),
  any_SGLT2_1 = any(df_hfref$SGLT2 == 1, na.rm = TRUE),
  
  # Descriptive only
  diuretics_nonmissing_rate = mean(!is.na(df_hfref$Diuretics)),
  pct_Diuretics_1 = mean(df_hfref$Diuretics == 1, na.rm = TRUE),
  loop_drugspecific_nonmissing_rate = mean(!is.na(df_hfref$LoopDiuretic_drug_specific)),
  pct_LoopDiuretic_drug_specific_1 = mean(df_hfref$LoopDiuretic_drug_specific == 1, na.rm = TRUE),
  
  max_HF_n_classes = suppressWarnings(max(df_hfref$HF_n_classes, na.rm = TRUE))
)
write_csv(audit, file.path(OUT_DIR, "hf_endpoint_audit.csv"))
log_line("[OK] Wrote hf_endpoint_audit.csv")

# Distribution (3-level grouped) — keep legacy filename for downstream scripts
dist_cat3 <- df_hfref %>%
  count(HF_GDMT_cat, name = "n") %>%
  mutate(pct = n / sum(n))

write_csv(dist_cat3, file.path(OUT_DIR, "hf_endpoint_distribution.csv"))
log_line("[OK] Wrote hf_endpoint_distribution.csv")

# Distribution (4-level count 0/1/2/3)
dist_count4 <- df_hfref %>%
  count(HF_GDMT_count4, name = "n") %>%
  mutate(pct = n / sum(n))

write_csv(dist_count4, file.path(OUT_DIR, "hf_endpoint_distribution_count4.csv"))
log_line("[OK] Wrote hf_endpoint_distribution_count4.csv")

# ====================================================================================
# 7) Save analysis dataset
# ====================================================================================
out_rds <- file.path(OUT_DIR, "df_study5_hfref.rds")
saveRDS(df_hfref, out_rds)

log_line("[DONE] Saved: ", out_rds)
log_line("[DONE] Script 1 finished successfully.")
#=================================#
