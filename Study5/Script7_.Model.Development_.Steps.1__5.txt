
# ==============================================================================
#  UmBIZOPROFID_ Study 5 
# Script 07: Model development
# IMPORTANT:
# This is an exploratory pipeline (not the primary MI interaction model).
# ==============================================================================
options(stringsAsFactors = FALSE)
suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(purrr)
  library(tibble)
  library(readr)
  library(forcats)
})

has_car <- requireNamespace("car", quietly = TRUE)
has_brglm2 <- requireNamespace("brglm2", quietly = TRUE)

# ==============================================================================
# 1) CONFIG
# ==============================================================================
ROOT_DIR <- "T:/Study_5"
SCRIPT1_DIR <- file.path(ROOT_DIR, "Results_Study5", "Script1_HFrEF_UPDATED")
IN_FILE <- file.path(SCRIPT1_DIR, "df_study5_hfref.rds")

OUT_DIR <- file.path(ROOT_DIR, "Results_Study5", "Script7_ModelDev_HFrEF_")
dir.create(OUT_DIR, recursive = TRUE, showWarnings = FALSE)

HFrEF_CUT <- 40

# Outcome preference
OUTCOME_PREFERRED <- "HF_BIN_eq3"
OUTCOME_FALLBACKS <- c("GDMT_BIN_geq3", "HF_BIN_geq3")

# Screening thresholds
P_SCREEN <- 0.10
P_RETAIN <- 0.05
CORR_THRES <- 0.70
MIN_N_UNI <- 200

# NA handling
DO_SIMPLE_IMPUTE <- TRUE
DROP_VARS_MISS_GT <- 0.95

# Factor sparsity collapse
COLLAPSE_SPARSE_LEVELS <- TRUE
MIN_LEVEL_TOTAL <- 20
MIN_LEVEL_EVENTS <- 5
# ==============================================================================
# 2) IO + helpers
# ==============================================================================
log_line <- function(...) cat(format(Sys.time(), "%Y-%m-%d %H:%M:%S"), " | ", paste0(...), "\n", sep = "")

write_tbl <- function(x, stem) {
  path <- file.path(OUT_DIR, paste0(stem, ".csv"))
  ok <- tryCatch({ readr::write_csv(x, path); TRUE }, error = function(e) FALSE)
  if (!ok) {
    alt <- file.path(tempdir(), paste0(stem, "_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv"))
    readr::write_csv(x, alt)
    log_line("[WARN] Could not write to OUT_DIR. Wrote instead: ", alt)
    return(invisible(alt))
  }
  log_line("[OK] Saved: ", path)
  invisible(path)
}

save_rds_safe <- function(x, stem) {
  path <- file.path(OUT_DIR, paste0(stem, ".rds"))
  ok <- tryCatch({ saveRDS(x, path); TRUE }, error = function(e) FALSE)
  if (!ok) {
    alt <- file.path(tempdir(), paste0(stem, "_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".rds"))
    saveRDS(x, alt)
    log_line("[WARN] Could not write to OUT_DIR. Saved instead: ", alt)
    return(invisible(alt))
  }
  log_line("[OK] Saved: ", path)
  invisible(path)
}

AUDIT_FAIL <- function(msg, extra = tibble()) {
  log_line("[ERROR] ", msg)
  out <- bind_cols(tibble(error = msg), extra)
  write_tbl(out, "AUDIT_fail")
  stop(msg)
}

pick_name <- function(nms, candidates) {
  hit <- candidates[candidates %in% nms]
  if (length(hit) == 0) return(NA_character_)
  hit[[1]]
}

safe_num <- function(x) suppressWarnings(as.numeric(as.character(x)))

to01_generic <- function(x) {
  if (is.logical(x)) return(as.integer(x))
  if (is.numeric(x) || is.integer(x)) return(as.integer(x))
  if (is.factor(x)) x <- as.character(x)
  if (is.character(x)) {
    x2 <- str_trim(str_to_lower(x))
    out <- rep(NA_integer_, length(x2))
    out[x2 %in% c("1","yes","y","true","t")] <- 1L
    out[x2 %in% c("0","no","n","false","f")] <- 0L
    suppressWarnings(out <- ifelse(is.na(out), as.integer(x2), out))
    return(as.integer(out))
  }
  NULL
}

to01_sex <- function(x) {
  if (is.numeric(x) || is.integer(x)) return(as.integer(x))
  if (is.factor(x)) x <- as.character(x)
  x2 <- str_trim(str_to_lower(as.character(x)))
  out <- rep(NA_integer_, length(x2))
  out[x2 %in% c("m","male","homme","man","1")] <- 1L
  out[x2 %in% c("f","female","femme","woman","0")] <- 0L
  suppressWarnings(out <- ifelse(is.na(out), as.integer(x2), out))
  out
}

n_unique_nonmiss <- function(x) length(unique(x[!is.na(x)]))

is_single_level <- function(x) {
  if (is.factor(x) || is.character(x)) return(nlevels(droplevels(as.factor(x))) < 2)
  n_unique_nonmiss(x) < 2
}

collapse_sparse <- function(d, outcome, var) {
  if (!is.factor(d[[var]])) return(d)
  tab <- d %>%
    filter(!is.na(.data[[outcome]])) %>%
    group_by(.data[[var]]) %>%
    summarise(
      n_total = n(),
      n_events = sum(.data[[outcome]] == 1, na.rm = TRUE),
      n_nonev = sum(.data[[outcome]] == 0, na.rm = TRUE),
      .groups = "drop"
    )
  rare <- tab %>%
    filter(n_total < MIN_LEVEL_TOTAL | n_events < MIN_LEVEL_EVENTS | n_nonev < MIN_LEVEL_EVENTS) %>%
    pull(.data[[var]])
  if (length(rare) > 0) {
    d[[var]] <- forcats::fct_collapse(d[[var]], Other = as.character(rare))
    d[[var]] <- droplevels(d[[var]])
  }
  d
}

tidy_or_wald <- function(fit) {
  sm <- tryCatch(summary(fit)$coefficients, error = function(e) NULL)
  if (is.null(sm) || nrow(sm) == 0) return(tibble())
  est <- sm[, "Estimate"]
  se <- sm[, "Std. Error"]
  p <- if ("Pr(>|z|)" %in% colnames(sm)) sm[, "Pr(>|z|)"] else rep(NA_real_, length(est))
  tibble(
    term = rownames(sm),
    OR = exp(est),
    CI_low = exp(est - 1.96 * se),
    CI_high = exp(est + 1.96 * se),
    p_value = as.numeric(p)
  ) %>% filter(term != "(Intercept)")
}

glm_separation_flag <- function(fit) {
  if (is.null(fit)) return(NA)
  pp <- tryCatch(fitted(fit), error = function(e) NULL)
  if (is.null(pp)) return(NA)
  any(pp < 1e-8 | pp > 1 - 1e-8, na.rm = TRUE)
}

fit_binomial_model <- function(formula, data) {
  warn_msg <- NA_character_
  fit <- tryCatch(
    withCallingHandlers(
      suppressWarnings(glm(formula, data = data, family = binomial(), control = glm.control(maxit = 50))),
      warning = function(w) { if (is.na(warn_msg)) warn_msg <<- conditionMessage(w); invokeRestart("muffleWarning") }
    ),
    error = function(e) NULL
  )
  if (is.null(fit)) return(list(fit = NULL, warning = warn_msg, model_type = NA_character_, separation_flag = NA))
  
  sep <- glm_separation_flag(fit)
  if (isTRUE(sep) && has_brglm2) {
    fit2 <- tryCatch(
      withCallingHandlers(
        suppressWarnings(brglm2::brglm(formula, data = data, family = binomial(), type = "AS_mean")),
        warning = function(w) { warn_msg <<- paste0("glm sep -> brglm2: ", conditionMessage(w)); invokeRestart("muffleWarning") }
      ),
      error = function(e) NULL
    )
    if (!is.null(fit2)) return(list(fit = fit2, warning = warn_msg, model_type = "brglm2", separation_flag = FALSE))
  }
  
  list(fit = fit, warning = warn_msg, model_type = "glm", separation_flag = sep)
}

get_term_pvalues_fast <- function(fit) {
  mm <- tryCatch(model.matrix(fit), error = function(e) NULL)
  sm <- tryCatch(summary(fit)$coefficients, error = function(e) NULL)
  if (is.null(mm) || is.null(sm) || nrow(sm) == 0) return(tibble(term = character(), p = numeric()))
  
  p <- sm[, "Pr(>|z|)"]
  names(p) <- rownames(sm)
  
  assign <- attr(mm, "assign")
  tl <- attr(terms(fit), "term.labels")
  cols <- colnames(mm)
  
  keep <- cols != "(Intercept)"
  cols <- cols[keep]
  assign <- assign[keep]
  
  term_for_col <- tl[assign]
  p_for_col <- p[match(cols, names(p))]
  
  tibble(term = term_for_col, p = p_for_col) %>%
    filter(!is.na(term)) %>%
    group_by(term) %>%
    summarise(p = max(p, na.rm = TRUE), .groups = "drop") %>% # conservative
    filter(is.finite(p))
}

# ==============================================================================
# 3) Load data
# ==============================================================================
if (!file.exists(IN_FILE)) AUDIT_FAIL(paste0("Input file not found: ", IN_FILE))
df_st5 <- readRDS(IN_FILE)
if (!is.data.frame(df_st5)) AUDIT_FAIL("Input is not a data.frame.")

log_line("[INFO] Loaded: N=", nrow(df_st5), " | p=", ncol(df_st5))
write_tbl(tibble(n = nrow(df_st5), p = ncol(df_st5)), "AUDIT_loaded")

# ==============================================================================
# 4) HFrEF restriction (LVEF < 40)
# ==============================================================================
lvef_var <- pick_name(names(df_st5), c("LVEF_num", "LVEF", "lvef", "lvef_num"))
if (!is.na(lvef_var)) {
  df_st5$LVEF_num <- safe_num(df_st5[[lvef_var]])
  df_st5 <- df_st5 %>% filter(!is.na(LVEF_num) & LVEF_num < HFrEF_CUT)
  log_line("[INFO] HFrEF: ", lvef_var, "<", HFrEF_CUT, " | N=", nrow(df_st5))
} else {
  AUDIT_FAIL("No LVEF variable found (expected LVEF_num/LVEF).")
}
if (nrow(df_st5) < 500) AUDIT_FAIL("HFrEF restriction leaves too few rows.", tibble(N_after = nrow(df_st5)))

# ==============================================================================
# 5) Outcome + forced covariates (robust naming)
# ==============================================================================
outcome_name <- NA_character_

if (OUTCOME_PREFERRED %in% names(df_st5)) {
  outcome_name <- OUTCOME_PREFERRED
} else {
  fb <- OUTCOME_FALLBACKS[OUTCOME_FALLBACKS %in% names(df_st5)]
  if (length(fb) > 0) {
    df_st5[[OUTCOME_PREFERRED]] <- to01_generic(df_st5[[fb[1]]])
    outcome_name <- OUTCOME_PREFERRED
  } else {
    cnt <- pick_name(names(df_st5), c("HF_n_classes","HF_GDMT_count4","HF_count","HF_therapies_n","HF_classes_n"))
    if (is.na(cnt)) AUDIT_FAIL("No outcome found and no HF count variable to derive HF_BIN_eq3.")
    df_st5[[cnt]] <- safe_num(df_st5[[cnt]])
    df_st5[[OUTCOME_PREFERRED]] <- ifelse(is.na(df_st5[[cnt]]), NA_integer_, as.integer(df_st5[[cnt]] >= 3))
    outcome_name <- OUTCOME_PREFERRED
  }
}

df_st5[[outcome_name]] <- to01_generic(df_st5[[outcome_name]])
log_line("[INFO] Outcome: ", outcome_name)

uv <- unique(na.omit(df_st5[[outcome_name]]))
if (!all(uv %in% c(0,1))) AUDIT_FAIL("Outcome not 0/1 after coercion.")
if (length(uv) < 2) AUDIT_FAIL("Outcome has <2 classes after HFrEF restriction.")

# Forced covariates
year_var <- pick_name(names(df_st5), c("Year_index","year_index","Year","year","calendar_year","Calendar_year"))
age_var <- pick_name(names(df_st5), c("Age_num","Age","age","age_num"))
sex_var <- pick_name(names(df_st5), c("Sex_BIN_Male","sex_bin_male","Sex","sex","Gender","gender","sexe"))
db_var <- pick_name(names(df_st5), c("DB","db","database","Database"))
icd_var <- pick_name(names(df_st5), c("ICD_status","ICD_BIN_Yes","ICD","icd_status","ICD_bin"))

if (is.na(year_var)) AUDIT_FAIL("Missing Year variable (Year_index/Year).")
if (is.na(age_var)) AUDIT_FAIL("Missing Age variable (Age_num/Age).")

df_st5$Year_index <- safe_num(df_st5[[year_var]])
df_st5$Age_num <- safe_num(df_st5[[age_var]])

# QC year range (audit only)
yr_rng <- range(df_st5$Year_index, na.rm = TRUE)
write_tbl(tibble(year_var = year_var, yr_min = yr_rng[1], yr_max = yr_rng[2]), "AUDIT_year_range")

# OR per 5-year increase (SAP)
# If Year_index is already "years since 2000" (0..20), the OR is still per 5 years => OK.
# If Year_index is calendar year (2000..2020), also OK.
yr_ref <- min(df_st5$Year_index, na.rm = TRUE)
df_st5$Year_5y <- (df_st5$Year_index - yr_ref) / 5

if (!is.na(db_var)) df_st5$DB <- droplevels(as.factor(df_st5[[db_var]])) else df_st5$DB <- factor("ALL")

if (!is.na(sex_var)) {
  sx <- to01_sex(df_st5[[sex_var]])
  if (!all(is.na(sx))) df_st5$Sex_BIN_Male <- factor(as.character(sx), levels = c("0","1"))
}

if (!is.na(icd_var)) {
  ic <- to01_generic(df_st5[[icd_var]])
  if (!all(is.na(ic))) df_st5$ICD_status <- droplevels(as.factor(ic))
}

force_in <- c("Year_5y","Age_num","LVEF_num","DB")
if ("Sex_BIN_Male" %in% names(df_st5) && !all(is.na(df_st5$Sex_BIN_Male))) force_in <- c(force_in, "Sex_BIN_Male")
if ("ICD_status" %in% names(df_st5) && !all(is.na(df_st5$ICD_status))) force_in <- c(force_in, "ICD_status")

write_tbl(tibble(forced = force_in), "AUDIT_forced_terms")

# ==============================================================================
# 6) Candidate predictors (leakage-safe) + exclusions
# ==============================================================================
# Hard exclusions: outcome/time vars + therapy vars/components of outcome
exclude_regex <- paste0(
  "(",
  # survival/time/process vars
  "^(Survival_time|Status|fstatus|py|ftime_mo_int|ftime_mo)$|",
  # time duplicates frequently present
  "^(Time_zero_Y|Year_index|Year_5y)$|",
  # ECG duplicates
  "^(QTC|QTc|OTc)$|",
  # outcome-related counts & therapy components (LEAKAGE)
  "^(HF_BIN_|HF_n_classes|HF_GDMT_count|HF_count|HF_therapies|GDMT_|gdmt_)|",
  "^(ACEI|ACE_|ARB$|ACEI_ARB|RAAS|BB$|Beta|MRA$|ARNI|SGLT2|Aldosterone_antagonist)|",
  # explicit medication groups sometimes named broadly
  "^(Antiplatelet|Anticoagulant|Lipid|Statin)",
  ")"
)

# Base exclusions list (IMPORTANT: initialize ->  "exclude_vars_base not found")
exclude_vars_base <- character(0)

# Drop Period_* (Option A)
exclude_vars_base <- unique(c(exclude_vars_base, grep("^Period_", names(df_st5), value = TRUE)))

# Also exclude the raw duplicates of forced vars if they exist (Age vs Age_num, LVEF vs LVEF_num, etc.)
exclude_vars_base <- unique(c(exclude_vars_base, age_var, lvef_var, year_var))

candidate_predictors <- setdiff(names(df_st5), exclude_vars_base)
candidate_predictors <- candidate_predictors[!grepl(exclude_regex, candidate_predictors, ignore.case = FALSE)]

# Drop ultra-missing
miss_prop <- sapply(candidate_predictors, function(v) mean(is.na(df_st5[[v]])))
candidate_predictors <- candidate_predictors[miss_prop <= DROP_VARS_MISS_GT]

# Final safety cleaning (prevents select(all_of()) crash)
candidate_predictors <- as.character(candidate_predictors)
candidate_predictors <- candidate_predictors[!is.na(candidate_predictors) & nzchar(candidate_predictors)]
candidate_predictors <- candidate_predictors[candidate_predictors %in% names(df_st5)]
candidate_predictors <- unique(candidate_predictors)

log_line("[INFO] Candidates after excludes/missing: ", length(candidate_predictors))
write_tbl(tibble(predictor = candidate_predictors, miss_prop = miss_prop[candidate_predictors]), "AUDIT_candidates")

if (length(candidate_predictors) < 5) AUDIT_FAIL("Too few candidate predictors after exclusions.", tibble(k = length(candidate_predictors)))

# ==============================================================================
# 7) Step 1 — Univariate screening
# ==============================================================================
fit_univariate_or <- function(data, outcome, pred, min_n = 200) {
  
  # PATCH #2: blindage pred
  if (is.na(pred) || !nzchar(pred) || !(pred %in% names(data))) return(NULL)
  
  d <- data %>% select(all_of(c(outcome, pred))) %>% filter(!is.na(.data[[outcome]]))
  
  if (is_single_level(d[[pred]])) return(NULL)
  
  if (is.character(d[[pred]])) d[[pred]] <- as.factor(d[[pred]])
  if (is.factor(d[[pred]])) {
    d[[pred]] <- forcats::fct_na_value_to_level(droplevels(d[[pred]]), level = "Missing")
  }
  
  d_cc <- d[complete.cases(d), , drop = FALSE]
  if (nrow(d_cc) < min_n) return(NULL)
  
  y <- d_cc[[outcome]]
  if (all(y == 0) || all(y == 1)) return(NULL)
  
  f <- as.formula(paste0(outcome, " ~ ", pred))
  got <- fit_binomial_model(f, d_cc)
  if (is.null(got$fit)) return(NULL)
  
  p_overall <- tryCatch({
    an <- drop1(got$fit, test = "Chisq")
    if (pred %in% rownames(an)) as.numeric(an[pred, "Pr(>Chi)"]) else NA_real_
  }, error = function(e) NA_real_)
  
  tidy_or_wald(got$fit) %>%
    mutate(
      predictor = pred,
      p_overall = p_overall,
      n_complete = nrow(d_cc),
      n_events = sum(d_cc[[outcome]] == 1, na.rm = TRUE),
      converged = isTRUE(got$fit$converged),
      separation_flag = got$separation_flag,
      warning = got$warning
    ) %>%
    select(predictor, term, OR, CI_low, CI_high, p_value, p_overall,
           n_complete, n_events, converged, separation_flag, warning)
}

log_line("[INFO] Univariate screening running (may take time)...")

# PATCH #1: safety cleaning just before map (belt + suspenders)
candidate_predictors <- candidate_predictors[!is.na(candidate_predictors) & nzchar(candidate_predictors)]
candidate_predictors <- candidate_predictors[candidate_predictors %in% names(df_st5)]
candidate_predictors <- unique(candidate_predictors)

uni_tbl <- purrr::map_dfr(candidate_predictors, ~fit_univariate_or(df_st5, outcome_name, .x, min_n = MIN_N_UNI))
if (nrow(uni_tbl) == 0) AUDIT_FAIL("Univariate screening produced empty table. Consider lowering MIN_N_UNI.", tibble(MIN_N_UNI = MIN_N_UNI))

write_tbl(uni_tbl, "MD_step1_univariate_OR")

uni_summary <- uni_tbl %>%
  group_by(predictor) %>%
  summarise(p_uni = suppressWarnings(min(c(p_overall, p_value), na.rm = TRUE)), .groups = "drop") %>%
  mutate(p_uni = ifelse(is.infinite(p_uni), NA_real_, p_uni))

write_tbl(uni_summary, "MD_step1_predictor_summary")

selected_pred0 <- uni_summary %>%
  filter(!is.na(p_uni) & p_uni <= P_SCREEN) %>%
  pull(predictor) %>% unique()

log_line("[INFO] Pre-selected at p<=", P_SCREEN, ": ", length(selected_pred0))
write_tbl(tibble(predictor = selected_pred0), "MD_step1_preselected_predictors")

if (length(selected_pred0) < 1) AUDIT_FAIL("No predictors pass univariate screen. Consider raising P_SCREEN or lowering MIN_N_UNI.")

# ==============================================================================
# 8) Step 2 — Correlation screen (numeric)
# ==============================================================================
num_candidates <- selected_pred0[vapply(df_st5[selected_pred0], function(x) is.numeric(x) || is.integer(x), logical(1))]
corr_tbl <- tibble()
drop_due_to_corr <- character(0)
if (length(num_candidates) >= 2) {
  cor_df <- df_st5 %>% select(all_of(num_candidates))
  nzv <- vapply(cor_df, function(x) n_unique_nonmiss(x) >= 2, logical(1))
  cor_df <- cor_df[, nzv, drop = FALSE]
  if (ncol(cor_df) >= 2) {
    cor_mat <- suppressWarnings(cor(cor_df, use = "pairwise.complete.obs"))
    idx <- which(abs(cor_mat) > CORR_THRES & upper.tri(cor_mat), arr.ind = TRUE)
    if (nrow(idx) > 0) {
      miss_fun <- function(v) {
        v <- as.character(v)
        if (is.na(v) || !(v %in% names(df_st5))) return(NA_real_)
        mean(is.na(df_st5[[v]]))
      }
      
      corr_tbl <- tibble(
        var1 = rownames(cor_mat)[idx[, 1]],
        var2 = colnames(cor_mat)[idx[, 2]],
        corr = as.numeric(cor_mat[idx])
      ) %>%
        mutate(
          var1 = as.character(var1),
          var2 = as.character(var2),
          miss1 = purrr::map_dbl(var1, miss_fun),
          miss2 = purrr::map_dbl(var2, miss_fun),
          drop_suggested = dplyr::if_else(miss1 > miss2, var1, var2)
        ) %>%
        arrange(desc(abs(corr)))
      drop_due_to_corr <- unique(corr_tbl$drop_suggested)
    }
  }
}

write_tbl(corr_tbl, "MD_step2_high_correlations")

selected_pred <- setdiff(selected_pred0, drop_due_to_corr)
selected_pred <- unique(selected_pred)

write_tbl(tibble(predictor = selected_pred), "MD_step3_selected_predictors")
log_line("[INFO] Selected after corr screen: ", length(selected_pred))

# ==============================================================================
# 9) Step 3.5 — Build modelling dataset (NA-safe)
# ==============================================================================
d_full <- df_st5 %>%
  select(all_of(unique(c(outcome_name, force_in, selected_pred)))) %>%
  filter(!is.na(.data[[outcome_name]])) %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), ~forcats::fct_na_value_to_level(droplevels(.x), level = "Missing")))

cc_min_vars <- intersect(unique(c(outcome_name, force_in)), names(d_full))
d_cc <- d_full %>%
  filter(if (length(cc_min_vars) > 0) complete.cases(across(all_of(cc_min_vars))) else TRUE)

log_line("[INFO] After minimal CC (outcome+forced): N=", nrow(d_cc),
         " | events=", sum(d_cc[[outcome_name]] == 1, na.rm = TRUE))

write_tbl(tibble(
  stage = "after_minimal_CC",
  n = nrow(d_cc),
  events = sum(d_cc[[outcome_name]] == 1, na.rm = TRUE)
), "AUDIT_na_prep")

if (nrow(d_cc) < 500) log_line("[WARN] N is small after minimal CC (N=", nrow(d_cc), ").")
if (sum(d_cc[[outcome_name]] == 1, na.rm = TRUE) == 0) AUDIT_FAIL("Zero events after NA-safe prep. Cannot fit model.")

if (isTRUE(COLLAPSE_SPARSE_LEVELS)) {
  fac_vars <- names(d_cc)[vapply(d_cc, is.factor, logical(1))]
  fac_vars <- setdiff(fac_vars, outcome_name)
  for (v in fac_vars) d_cc <- collapse_sparse(d_cc, outcome_name, v)
}

if (isTRUE(DO_SIMPLE_IMPUTE)) {
  num_vars <- names(d_cc)[vapply(d_cc, is.numeric, logical(1))]
  num_vars <- setdiff(num_vars, outcome_name)
  
  for (v in num_vars) {
    miss <- is.na(d_cc[[v]])
    if (any(miss)) {
      d_cc[[paste0(v, "_mis")]] <- as.integer(miss)
      d_cc[[v]][miss] <- median(d_cc[[v]], na.rm = TRUE)
    }
  }
  log_line("[INFO] Median imputation + _mis flags applied for numeric vars with NA.")
}

# ==============================================================================
# 10) Step 4 — Full model + backward elimination 
# ==============================================================================
all_terms <- setdiff(names(d_cc), outcome_name)

terms_ordered <- c(force_in, setdiff(all_terms, force_in))
terms_ordered <- terms_ordered[terms_ordered %in% names(d_cc)]

bad_single <- terms_ordered[vapply(terms_ordered, function(v) is_single_level(d_cc[[v]]), logical(1))]
if (length(bad_single) > 0) {
  write_tbl(tibble(dropped = bad_single, reason = "single level after NA-prep"), "MD_step4_dropped_single_level_terms")
  terms_ordered <- setdiff(terms_ordered, bad_single)
}
if (length(terms_ordered) < 1) AUDIT_FAIL("No usable predictors after single-level drop.")

full_formula <- as.formula(paste0(outcome_name, " ~ ", paste(terms_ordered, collapse = " + ")))

got0 <- fit_binomial_model(full_formula, d_cc)
fit_current <- got0$fit
if (is.null(fit_current)) AUDIT_FAIL("Initial full model failed to fit.", tibble(warning = got0$warning, model_type = got0$model_type))

initial_diag <- tibble(
  stage = "initial_full_model",
  model_type = got0$model_type,
  separation_flag = got0$separation_flag,
  warning = got0$warning,
  n_complete = nrow(d_cc),
  n_events = sum(d_cc[[outcome_name]] == 1, na.rm = TRUE),
  n_terms = length(attr(terms(full_formula), "term.labels"))
)
write_tbl(initial_diag, "MD_step4_initial_model_diagnostics")

force_in2 <- intersect(force_in, attr(terms(formula(fit_current)), "term.labels"))

backward_log <- list()
iter <- 0

repeat {
  iter <- iter + 1
  tp <- get_term_pvalues_fast(fit_current)
  if (nrow(tp) == 0) break
  
  tp2 <- tp %>% filter(!(term %in% force_in2))
  if (nrow(tp2) == 0) break
  
  worst <- tp2 %>% arrange(desc(p)) %>% slice(1)
  if (!is.finite(worst$p) || worst$p <= P_RETAIN) break
  
  worst_term <- worst$term
  backward_log[[iter]] <- tibble(iteration = iter, removed_term = worst_term, removed_p = worst$p)
  
  new_terms <- setdiff(attr(terms(formula(fit_current)), "term.labels"), worst_term)
  if (length(new_terms) == 0) break
  
  new_formula <- as.formula(paste0(outcome_name, " ~ ", paste(new_terms, collapse = " + ")))
  got_next <- fit_binomial_model(new_formula, d_cc)
  
  if (is.null(got_next$fit)) {
    backward_log[[iter]] <- backward_log[[iter]] %>% mutate(note = "refit failed; stop elimination")
    break
  }
  
  fit_current <- got_next$fit
  force_in2 <- intersect(force_in2, attr(terms(formula(fit_current)), "term.labels"))
}

write_tbl(bind_rows(backward_log), "MD_step4_backward_log")

final_or <- tidy_or_wald(fit_current) %>%
  mutate(
    n_complete = nrow(d_cc),
    n_events = sum(d_cc[[outcome_name]] == 1, na.rm = TRUE)
  )
write_tbl(final_or, "MD_step4_final_model_OR")

# cleaner OR table (hide DB terms but keep DB in the model)
final_or_clean <- final_or %>%
  filter(!grepl("^DB", term))
write_tbl(final_or_clean, "MD_step4_final_model_OR_noDB")

save_rds_safe(list(
  model = fit_current,
  formula = formula(fit_current),
  n_complete = nrow(d_cc),
  n_events = sum(d_cc[[outcome_name]] == 1, na.rm = TRUE),
  forced_in = force_in,
  terms = attr(terms(formula(fit_current)), "term.labels")
), "MD_step4_final_model_object")

# ==============================================================================
# 11) Step 5 — Diagnostics + VIF (no crash)
# ==============================================================================
final_terms <- tryCatch(attr(terms(formula(fit_current)), "term.labels"), error = function(e) character(0))

final_diag <- tibble(
  stage = "final_model",
  model_type = got0$model_type,
  separation_flag = glm_separation_flag(fit_current),
  warning = got0$warning,
  n_complete = nrow(d_cc),
  n_events = sum(d_cc[[outcome_name]] == 1, na.rm = TRUE),
  n_terms = length(final_terms)
)
write_tbl(final_diag, "MD_step5_final_model_diagnostics")

vif_tbl <- tibble(note = "VIF not computed.")
if (has_car && length(final_terms) > 0) {
  lm_fit <- tryCatch(lm(formula(fit_current), data = d_cc), error = function(e) NULL)
  if (!is.null(lm_fit)) {
    aliased <- is.na(coef(lm_fit))
    if (any(aliased)) {
      vif_tbl <- tibble(note = "Aliased coefficient (model not full rank). VIF/GVIF not computed.")
    } else {
      v <- tryCatch(car::vif(lm_fit), error = function(e) NULL)
      if (is.matrix(v)) {
        vif_tbl <- tibble(
          term = rownames(v),
          GVIF = as.numeric(v[, "GVIF"]),
          Df = as.numeric(v[, "Df"]),
          GVIF_adj = as.numeric(v[, "GVIF"])^(1 / (2 * as.numeric(v[, "Df"])))
        )
      } else if (!is.null(v)) {
        vif_tbl <- tibble(term = names(v), VIF = as.numeric(v))
      } else {
        vif_tbl <- tibble(note = "car::vif failed (likely due to instability).")
      }
    }
  } else {
    vif_tbl <- tibble(note = "lm() failed; VIF not available.")
  }
}
write_tbl(vif_tbl, "MD_step5_vif")

log_line("[OK] Script 07 completed. Output folder: ", OUT_DIR)

