# ==============================================================================
# UmBIZO — PROFID Study 5 
# Script 07: Model development ( steps 1–5)
# Author: Amina BOUDAMAANA
# Cohort: HFrEF only (LVEF <40%) from Script 1 output df_study5_hfref.rds
# Window: 2000–2020
# Primary outcome (binary): HF_BIN_eq3 = 1 if HF_n_classes == 3 (RAAS + BB + MRA)
#
# Steps:
# 1) Univariate screening (p<0.10)
# 2) Correlation filtering (|r| > 0.70 among numeric predictors)
# 3) Candidate set = screened + clinically forced vars
# 4) Backward elimination (retain p<0.05; forced vars always kept)
# 5) Multicollinearity check (VIF < 5)
#
# Outputs
# - 01_univariate_OR
# - 02_corr_matrix_numeric + 02_corr_pairs_over_0p70
# - 03_candidates_after_screening
# - 04_selection_path
# - 05_final_model_OR + 05_final_model_VIF
# - final_model.rds
# ==============================================================================
options(stringsAsFactors = FALSE)
suppressPackageStartupMessages({
  library(dplyr)
  library(tibble)
  library(readr)
  library(broom)
  library(purrr)
})

log_line <- function(...) cat(paste0(..., "\n"))
# ===================================================================================
# 0) PATHS
# ===================================================================================
ROOT_DIR <- "T:/Study_5"
RESULTS_ROOT <- file.path(ROOT_DIR, "Results_Study5")

IN_FILE <- file.path(RESULTS_ROOT, "Script1_HFrEF_UPDATED", "df_study5_hfref.rds")

OUT_DIR <- file.path(RESULTS_ROOT, "Script7_ModelDevelopment_HFrEF")
dir.create(OUT_DIR, recursive = TRUE, showWarnings = FALSE)

stopifnot(file.exists(IN_FILE))
df <- readRDS(IN_FILE)
# =============================================================================
# 1) Harmonise cohort window + outcome
# =============================================================================
#  restriction 2000–2020
if (!("Year_index" %in% names(df))) stop("Year_index not found in df.")
df <- df %>%
  filter(!is.na(Year_index), Year_index >= 2000L, Year_index <= 2020L)

# outcome
to_num01 <- function(x) {
  if (is.factor(x)) x <- as.character(x)
  if (is.logical(x)) return(as.integer(x))
  if (is.numeric(x)) return(ifelse(is.na(x), NA_integer_, as.integer(x != 0)))
  x2 <- tolower(trimws(as.character(x)))
  ifelse(is.na(x2), NA_integer_,
         ifelse(x2 %in% c("1","yes","y","true","t"), 1L,
                ifelse(x2 %in% c("0","no","n","false","f"), 0L, NA_integer_)))
}

if (!("HF_BIN_eq3" %in% names(df))) {
  if ("HF_n_classes" %in% names(df)) {
    df$HF_BIN_eq3 <- as.integer(df$HF_n_classes == 3)
  } else {
    stop("Neither HF_BIN_eq3 nor HF_n_classes found. Re-run Script 1/2.")
  }
} else {
  df$HF_BIN_eq3 <- to_num01(df$HF_BIN_eq3)
}

# basic predictors harmonisation
if (!("Age_num" %in% names(df)) && ("Age" %in% names(df))) {
  df$Age_num <- suppressWarnings(as.numeric(df$Age))
}
if ("Sex_BIN_Male" %in% names(df)) df$Sex_BIN_Male <- to_num01(df$Sex_BIN_Male)

# Drop Baseline_within40d if constant (common)
clinical_vars <- c(
  "LVEF_num",
  "ICD_BIN_Yes",
  "Baseline_within40d",
  "Time_index_MI_CHD_log1p",
  "Diabetes_BIN_Yes", "Hypertension_BIN_Yes",
  "Smoking_BIN_Yes", "AF_atrial_flutter_BIN_Yes",
  "Stroke_TIA_BIN_Yes"
)
if ("Baseline_within40d" %in% names(df)) {
  tab_b40 <- table(df$Baseline_within40d, useNA = "ifany")
  log_line("[CHECK] Baseline_within40d distribution:")
  print(tab_b40)
  if (length(unique(df$Baseline_within40d[!is.na(df$Baseline_within40d)])) < 2) {
    clinical_vars <- setdiff(clinical_vars, "Baseline_within40d")
    log_line("[NOTE] Baseline_within40d constant -> excluded.")
  }
}

demographic_vars <- intersect(c("Age_num", "Sex_BIN_Male", "DB"), names(df))

lab_vars_all <- c("eGFR_log1p", "NTProBNP_log1p", "Haemoglobin_log1p", "Sodium_log1p", "Potassium_log1p")
procedure_vars <- c("PCI_BIN_Yes", "CABG_BIN_Yes", "Revascularisation_acute_BIN_Yes")

keep_existing <- function(v) intersect(v, names(df))
temporal_vars <- keep_existing(c("Year_index"))
clinical_vars <- keep_existing(clinical_vars)
lab_vars_all <- keep_existing(lab_vars_all)
procedure_vars<- keep_existing(procedure_vars)

# exclude labs with >=80% missing (align Script 3 note)
if (length(lab_vars_all) > 0) {
  miss_rate <- sapply(lab_vars_all, function(v) mean(is.na(df[[v]])))
  labs_keep <- names(miss_rate)[miss_rate < 0.80]
  labs_drop <- setdiff(lab_vars_all, labs_keep)
  if (length(labs_drop) > 0) {
    log_line("[NOTE] Dropping labs with >=80% missing: ", paste(labs_drop, collapse=", "))
  }
  lab_vars <- labs_keep
} else {
  lab_vars <- character(0)
}

candidate_vars_all <- unique(c(temporal_vars, demographic_vars, clinical_vars, lab_vars, procedure_vars))
candidate_vars_all <- setdiff(candidate_vars_all, c("HF_BIN_eq3")) # not predictor

# forced (clinically / structure) vars always kept in multivariable
forced_vars <- intersect(c("Year_index", "Age_num", "Sex_BIN_Male", "DB"), names(df))

log_line("[INFO] N=", nrow(df), " | Events=", sum(df$HF_BIN_eq3==1, na.rm=TRUE))
log_line("[INFO] Forced vars: ", paste(forced_vars, collapse=", "))
log_line("[INFO] Candidate vars total: ", length(candidate_vars_all))

# =============================================================================
# 2) Step 1 — Univariate screening
# =============================================================================
fit_uni <- function(var) {
  f <- as.formula(paste0("HF_BIN_eq3 ~ ", var))
  dsub <- df %>% select(all_of(c("HF_BIN_eq3", var))) %>% na.omit()
  if (nrow(dsub) < 200) {
    return(tibble(variable=var, n=nrow(dsub), OR=NA_real_, CI_low=NA_real_, CI_high=NA_real_, p=NA_real_, note="n<200"))
  }
  fit <- suppressWarnings(glm(f, data=dsub, family=binomial()))
  tt <- broom::tidy(fit, conf.int=TRUE, exponentiate=TRUE)
  tt <- tt %>% filter(term != "(Intercept)")
  if (nrow(tt)==0) return(tibble(variable=var, n=nrow(dsub), OR=NA_real_, CI_low=NA_real_, CI_high=NA_real_, p=NA_real_, note="no term"))
  tibble(
    variable = var,
    n = nrow(dsub),
    OR = tt$estimate[1],
    CI_low = tt$conf.low[1],
    CI_high = tt$conf.high[1],
    p = tt$p.value[1],
    note = ""
  )
}

uni_tbl <- map_dfr(candidate_vars_all, fit_uni) %>%
  arrange(is.na(p), p)

write_csv(uni_tbl, file.path(OUT_DIR, "01_univariate_OR.csv"))
log_line("[DONE] Wrote 01_univariate_OR.csv")

# screen p<0.10
screen_vars <- uni_tbl %>%
  filter(!is.na(p), p < 0.10) %>%
  pull(variable) %>% unique()

# ensure forced always included
screen_vars <- unique(c(forced_vars, screen_vars))
write_csv(tibble(candidate=screen_vars), file.path(OUT_DIR, "03_candidates_after_screening.csv"))
log_line("[DONE] Wrote 03_candidates_after_screening.csv | n=", length(screen_vars))
# =============================================================================
# 3) Step 2 — Correlation filtering among numeric predictors (|r|>0.70)
# =============================================================================
is_numericish <- function(x) is.numeric(x) || is.integer(x)
num_vars <- screen_vars[screen_vars %in% names(df)]
num_vars <- num_vars[sapply(df[num_vars], is_numericish)]

corr_pairs <- tibble()
corr_mat <- NULL

if (length(num_vars) >= 2) {
  dnum <- df %>% select(all_of(num_vars))
  corr_mat <- suppressWarnings(cor(dnum, use="pairwise.complete.obs", method="pearson"))
  write_csv(as_tibble(corr_mat, .name_repair="minimal") %>% mutate(var=row.names(corr_mat), .before=1),
            file.path(OUT_DIR, "02_corr_matrix_numeric.csv"))
  log_line("[DONE] Wrote 02_corr_matrix_numeric.csv")
  
  # extract pairs
  cm <- corr_mat
  cm[lower.tri(cm, diag=TRUE)] <- NA_real_
  idx <- which(abs(cm) > 0.70, arr.ind=TRUE)
  if (nrow(idx) > 0) {
    corr_pairs <- tibble(
      var1 = rownames(cm)[idx[,1]],
      var2 = colnames(cm)[idx[,2]],
      r = cm[idx]
    ) %>% arrange(desc(abs(r)))
    write_csv(corr_pairs, file.path(OUT_DIR, "02_corr_pairs_over_0p70.csv"))
    log_line("[NOTE] Found correlated pairs |r|>0.70: ", nrow(corr_pairs))
  } else {
    write_csv(tibble(message="No |r|>0.70 pairs."), file.path(OUT_DIR, "02_corr_pairs_over_0p70.csv"))
    log_line("[INFO] No correlated numeric pairs over threshold.")
  }
} else {
  write_csv(tibble(message="Too few numeric vars for correlation step."), file.path(OUT_DIR, "02_corr_pairs_over_0p70.csv"))
}

# we drop rule: for each correlated pair, drop higher missingness
drop_vars <- character(0)
if (nrow(corr_pairs) > 0) {
  miss <- sapply(num_vars, function(v) mean(is.na(df[[v]])))
  for (i in seq_len(nrow(corr_pairs))) {
    a <- corr_pairs$var1[i]; b <- corr_pairs$var2[i]
    if (a %in% drop_vars || b %in% drop_vars) next
    ma <- miss[[a]]; mb <- miss[[b]]
    if (is.na(ma) || is.na(mb)) next
    if (ma > mb) drop_vars <- c(drop_vars, a) else if (mb > ma) drop_vars <- c(drop_vars, b) else drop_vars <- c(drop_vars, b)
  }
}
cand_vars <- setdiff(screen_vars, drop_vars)
cand_vars <- unique(c(forced_vars, cand_vars)) # forced stay
write_csv(tibble(kept=cand_vars, dropped_corr=ifelse(cand_vars %in% drop_vars, 1, 0)),
          file.path(OUT_DIR, "03_candidates_after_corr_filter.csv"))
log_line("[DONE] Wrote 03_candidates_after_corr_filter.csv | kept=", length(cand_vars))
# ===================================================================================
# 4) Step 4 — Backward elimination (retain p<0.05; forced always kept)
# ===================================================================================
build_df_for_fit <- function(vars) {
  df %>% select(all_of(unique(c("HF_BIN_eq3", vars)))) %>% na.omit()
}

safe_glm <- function(vars) {
  dfit <- build_df_for_fit(vars)
  if (nrow(dfit) < 500) return(list(fit=NULL, n=nrow(dfit), msg="n<500 after complete-case"))
  f <- as.formula(paste0("HF_BIN_eq3 ~ ", paste(vars, collapse=" + ")))
  fit <- tryCatch(glm(f, data=dfit, family=binomial()), error=function(e) NULL)
  list(fit=fit, n=nrow(dfit), msg=ifelse(is.null(fit), "glm failed", "ok"))
}

selection_path <- tibble(step=integer(), removed=character(), max_p=numeric(), n=integer(), note=character())

current_vars <- cand_vars
step <- 0

repeat {
  step <- step + 1
  res <- safe_glm(current_vars)
  if (is.null(res$fit)) {
    selection_path <- bind_rows(selection_path, tibble(step=step, removed=NA_character_, max_p=NA_real_, n=res$n, note=res$msg))
    break
  }
  
  tt <- broom::tidy(res$fit)
  tt <- tt %>% filter(term != "(Intercept)")
  # map term to variable (handles factor levels)
  tt <- tt %>%
    mutate(variable = sub("^`|`$", "", term),
           variable = sub("^([^:]+):.*$", "\\1", variable)) # keep left side if interaction appears
  
  # we compute p by variable: take max p across its levels (conservative)
  p_by_var <- tt %>%
    group_by(variable) %>%
    summarise(p_max = max(p.value, na.rm=TRUE), .groups="drop")
  
  # only removable vars (non-forced)
  removable <- setdiff(current_vars, forced_vars)
  if (length(removable) == 0) {
    selection_path <- bind_rows(selection_path, tibble(step=step, removed="(none)", max_p=NA_real_, n=res$n, note="Only forced vars remain"))
    final_fit <- res$fit
    final_n <- res$n
    break
  }
  
  p_rem <- p_by_var %>% filter(variable %in% removable) %>% arrange(desc(p_max))
  if (nrow(p_rem)==0) {
    selection_path <- bind_rows(selection_path, tibble(step=step, removed="(none)", max_p=NA_real_, n=res$n, note="No removable terms found"))
    final_fit <- res$fit
    final_n <- res$n
    break
  }
  
  worst <- p_rem$variable[1]
  worst_p <- p_rem$p_max[1]
  
  if (!is.finite(worst_p) || worst_p <= 0.05) {
    selection_path <- bind_rows(selection_path, tibble(step=step, removed="(stop)", max_p=worst_p, n=res$n, note="All removable vars p<=0.05"))
    final_fit <- res$fit
    final_n <- res$n
    break
  }
  
  # we remove worst
  current_vars <- setdiff(current_vars, worst)
  selection_path <- bind_rows(selection_path, tibble(step=step, removed=worst, max_p=worst_p, n=res$n, note="removed"))
}

write_csv(selection_path, file.path(OUT_DIR, "04_selection_path.csv"))
log_line("[DONE] Wrote 04_selection_path.csv")

if (!exists("final_fit") || is.null(final_fit)) stop("Final model not available (fit failed).")

saveRDS(final_fit, file.path(OUT_DIR, "final_model.rds"))
log_line("[DONE] Saved final_model.rds")
# ====================================================================================
# 5) Final model table (OR/CI) + VIF
# ====================================================================================
final_or <- broom::tidy(final_fit, conf.int=TRUE, exponentiate=TRUE) %>%
  filter(term != "(Intercept)") %>%
  transmute(term,
            OR=estimate,
            CI_low=conf.low,
            CI_high=conf.high,
            p=p.value)

write_csv(final_or, file.path(OUT_DIR, "05_final_model_OR.csv"))
log_line("[DONE] Wrote 05_final_model_OR.csv | N_cc=", final_n)

# VIF (prefer car::vif if available; otherwise manual via R^2)
compute_vif_manual <- function(fit) {
  mm <- model.matrix(fit)
  mm <- mm[, colnames(mm) != "(Intercept)", drop=FALSE]
  if (ncol(mm) < 2) return(tibble(term=colnames(mm), VIF=1))
  out <- lapply(seq_len(ncol(mm)), function(j) {
    y <- mm[, j]
    x <- mm[, -j, drop=FALSE]
    r2 <- suppressWarnings(summary(lm(y ~ x))$r.squared)
    vif <- 1 / (1 - r2)
    tibble(term=colnames(mm)[j], VIF=vif)
  })
  bind_rows(out)
}

vif_tbl <- NULL
if (requireNamespace("car", quietly=TRUE)) {
  vif_raw <- tryCatch(car::vif(final_fit), error=function(e) NULL)
  if (!is.null(vif_raw)) {
    vif_tbl <- tibble(term=names(vif_raw), VIF=as.numeric(vif_raw))
  }
}
if (is.null(vif_tbl)) {
  vif_tbl <- compute_vif_manual(final_fit)
}

write_csv(vif_tbl, file.path(OUT_DIR, "05_final_model_VIF.csv"))
log_line("[DONE] Wrote 05_final_model_VIF.csv")

log_line("[DONE] Script 07 finished.")
